<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Sensy-One Zone Editor</title>
<style>
  :root{
    --ui: 1;
    --bg:#06070a; --panel:#0a0c11; --panel-2:#0b0d12; --ctrl:#10131a; --bd:#171b22;
    --fg:#e6eaf1; --muted:#9aa3ad; --ok:#22c55e; --err:#ef4444;
    --canvas:#0a0d12; --fov:#7082a8;
    --z-norm:#64c09e; --z-norm-fill:rgba(126,240,197,.19); --z-norm-dim:#459f7e; --z-norm-dim-fill:rgba(86,199,157,.11);
    --z-excl:#cc6f6f; --z-excl-fill:rgba(255,139,139,.18); --z-excl-dim:#b35d5d; --z-excl-dim-fill:rgba(255,139,139,.10);
    --pulse:rgba(185,194,207,0.9); --grid:#1e2431;
    --pad0: 10px; --gap0: 10px; --btnh0: 36px; --radius0: 12px;
    --fs0: 14px; --title0: 14px; --small0: 12px;
    --pad: calc(var(--pad0) * var(--ui));
    --gap: calc(var(--gap0) * var(--ui));
    --btnh: calc(var(--btnh0) * var(--ui));
    --radius: calc(var(--radius0) * var(--ui));
    --fs: calc(var(--fs0) * var(--ui));
    --title: calc(var(--title0) * var(--ui));
    --small: calc(var(--small0) * var(--ui));
    --base-canvas-w: 1200px;
    --base-canvas-h: 720px;
    --base-panel-w: 400px;
    --canvas-w: calc(var(--base-canvas-w) * var(--ui));
    --panel-w:  calc(var(--base-panel-w)  * var(--ui));
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--fg);font:var(--fs)/1.4 system-ui,Segoe UI,Roboto,Arial}
  .container{width:100%;min-height:100vh;margin:0 auto;padding:var(--pad);display:grid;gap:var(--gap);
    grid-template-columns:minmax(0,var(--canvas-w)) var(--panel-w);align-items:start;max-width:calc(var(--canvas-w) + var(--panel-w) + var(--gap));}
  @media (max-width:1150px){.container{grid-template-columns:1fr;gap:calc(var(--gap0)*0.6);max-width:100%;}}
  .card{background:linear-gradient(180deg,var(--panel),var(--panel-2));border:1px solid var(--bd);border-radius:var(--radius);min-width:0;}
  .canvas-wrap{padding:calc(6px * var(--ui)); position:relative;}
  #canvas{display:block;width:var(--canvas-w);height:calc(var(--base-canvas-h) * var(--ui));max-width:100%;height:auto;aspect-ratio:1200/720;
    border-radius:calc(10px * var(--ui));touch-action:none;background:var(--canvas);}

  .legend,
  .view-toggle,
  .floorplan-toggle,
  .floorplan-tools,
  .floorplan-history{
    display:flex;
    align-items:center;
    gap:calc(8px * var(--ui));
    background:#0b0f17cc;
    border:1px solid #1a2030;
    border-radius:calc(10px * var(--ui));
    padding:calc(6px * var(--ui));
    min-height:var(--btnh);
  }
  .view-toggle{
    position:absolute;
    right:12px;
    top:12px;
    z-index:5;
  }
  .floorplan-toggle{
    position:absolute;
    left:12px;
    top:12px;
    z-index:5;
  }
  .floorplan-tools{
    position:absolute;
    right:12px;
    bottom:12px;
    z-index:5;
  }
  .floorplan-history{
    position:absolute;
    left:12px;
    bottom:12px;
    z-index:5;
  }

  .view-toggle-btn{
    border:none;
    background:transparent;
    color:#b9c2cf;
    font-size:12px;
    min-width:calc(32px * var(--ui));
    height:var(--btnh);
    padding:0 calc(10px * var(--ui));
    line-height:1;
    display:flex;
    align-items:center;
    justify-content:center;
    border-radius:6px;
    cursor:pointer;
  }
  .legend-btn{
    padding:0;
    min-width:var(--btnh);
  }
  .view-toggle-btn .btn-icon{
    width:calc(26px * var(--ui));
    height:calc(26px * var(--ui));
    display:inline-flex;
    align-items:center;
    justify-content:center;
  }
  .btn-icon svg{
    width:100%;
    height:100%;
    stroke:currentColor;
    fill:none;
    stroke-width:1.2;
    stroke-linecap:round;
    stroke-linejoin:round;
  }
  .view-toggle-btn.icon-only{
    padding:0;
    min-width:var(--btnh);
    width:var(--btnh);
    justify-content:center;
  }
  .floorplan-tools .view-toggle-btn{
    min-width:0;
  }
  .floorplan-history .view-toggle-btn{
    min-width:0;
  }
  .view-toggle-btn.active{
    background:#151b28;
    color:#e6eaf1;
  }

  .legend{
    position:absolute;
    right:12px;
    bottom:12px;
  }
  .legend-bar{
    width:120px;
    height:8px;
    border-radius:999px;
    background:linear-gradient(90deg,#0d2038,#2a7bff,#41ffd4,#a6ff63,#ffe066,#ff9a5c,#ff6b6b);
  }
  @media (max-width:700px){
  .legend,
  .view-toggle{
    padding:calc(4px * var(--ui));
    gap:calc(6px * var(--ui));
    min-height:calc(34px * var(--ui));
    right:8px;
  }
  .floorplan-toggle{
    padding:calc(4px * var(--ui));
    gap:calc(6px * var(--ui));
    min-height:calc(34px * var(--ui));
    left:8px;
    top:8px;
  }
  .floorplan-tools{
    padding:calc(4px * var(--ui));
    gap:calc(6px * var(--ui));
    min-height:calc(34px * var(--ui));
    left:8px;
    bottom:8px;
  }

  .view-toggle{
    top:8px;
  }

  .legend{
    bottom:8px;
  }

  .view-toggle-btn{
    min-width:calc(24px * var(--ui));
    height:calc(24px * var(--ui));
    padding:0 4px;
    font-size:12px;
    border-radius:6px;
  }

  .legend-btn{
    min-width:calc(24px * var(--ui));
    height:calc(24px * var(--ui));
    padding:0;
  }

  .legend-bar{
    width:80px;
    height:6px;
  }

}

  .panel{padding:var(--pad);display:flex;flex-direction:column;gap:var(--gap);overflow:auto;}
  .section{background:var(--ctrl);border:1px solid var(--bd);border-radius:calc(10px * var(--ui));padding:calc(10px * var(--ui));display:flex;flex-direction:column;gap:calc(4px * var(--ui));min-width:0;}
  .row{display:flex;gap:calc(6px * var(--ui));align-items:center;flex-wrap:nowrap}
  .row.equal>*{flex:1 1 0;min-width:0}
  input,button,select{height:var(--btnh);border-radius:calc(9px * var(--ui));border:1px solid #1a1f2a;background:#121620;color:var(--fg);padding:0 calc(10px * var(--ui));font:inherit;outline:none;min-width:0;max-width:100%;}
  input.readonly{pointer-events:none}
  button{cursor:pointer;transition:transform .04s,background-color .15s,border-color .15s;white-space:nowrap;text-align:center}
  .btn-primary{background:#151b28;border-color:#202638}.btn-primary:hover{background:#192132;border-color:#2a3550}.btn-primary:active{transform:translateY(1px)}
  .btn-plain{background:#121620;border-color:#1a1f2a}.btn-plain:hover{background:#151a24;border-color:#212836}
  select{cursor:pointer;appearance:none;-webkit-appearance:none;-moz-appearance:none;background-image:url("data:image/svg+xml,%3Csvg width='16' height='16' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M7 10l5 5 5-5' stroke='%23cfd6e2' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");background-repeat:no-repeat;background-position:right calc(8px * var(--ui)) center;padding-right:calc(26px * var(--ui));}
  input[type=number]::-webkit-outer-spin-button,input[type=number]::-webkit-inner-spin-button{-webkit-appearance:none;margin:0}
  input[type=number]{-moz-appearance:textfield;appearance:textfield}
  .title{font-size:var(--title);font-weight:600;color:#cfd6e2}
  .dot{width:calc(10px * var(--ui));height:calc(10px * var(--ui));border-radius:50%;background:#343a46;flex:0 0 auto}
  .dot.ok{background:var(--ok)} .dot.err{background:var(--err)}
  .input-with-icon{position:relative;width:100%;}
  .status-icon{position:absolute;left:calc(10px * var(--ui));top:50%;transform:translateY(-50%);pointer-events:none;}
  .status-input{width:100%;padding-left:calc(10px * var(--ui) + 12px * var(--ui) + 8px);}
  .zones{display:grid;grid-template-columns:1fr;gap:calc(6px * var(--ui))}
  .zone-btn{height:calc(34px * var(--ui));font-size:calc(13px * var(--ui))}
  .zone-btn.active{background:#151e2c;border-color:#2a3550}
  .row.equal .btn-primary,.row.equal .btn-plain{min-width:calc(96px * var(--ui))}
  @media (max-width:1150px){
    :root{--btnh0:34px}
    .canvas-wrap{padding:calc(4px * var(--ui))}
    .panel{padding:calc(6px * var(--ui));gap:calc(6px * var(--ui))}
    .zones{gap:calc(6px * var(--ui))}
  }

</style>
</head>
<body style="opacity:0;">
  <div class="container" id="container">
    <div id="canvasCard" class="card canvas-wrap">
      <canvas id="canvas"></canvas>

      <div class="floorplan-toggle" id="floorplanToggle">
        <button class="view-toggle-btn" id="floorplanBtn" aria-pressed="false">Floorplan</button>
      </div>

      <div class="view-toggle" id="viewToggle">
        <button class="view-toggle-btn active" data-view="2d">2D</button>
        <button class="view-toggle-btn" data-view="3d">3D</button>
      </div>

      <div class="floorplan-tools" id="floorplanTools" style="display:none" aria-label="Floorplan tools">
        <button class="view-toggle-btn floorplan-tool-btn icon-only" data-tool="draw" aria-label="Walls tool" aria-pressed="false">
          <span class="btn-icon" aria-hidden="true">
            <svg viewBox="0 0 24 24">
              <circle cx="7" cy="17" r="2"></circle>
              <circle cx="17" cy="7" r="2"></circle>
              <path d="M8.5 15.5 15.5 8.5"></path>
            </svg>
          </span>
        </button>
        <button class="view-toggle-btn floorplan-tool-btn icon-only" data-tool="sensor" aria-label="Sensors tool" aria-pressed="false">
          <span class="btn-icon" aria-hidden="true">
            <svg viewBox="0 0 24 24">
              <circle cx="12" cy="12" r="1.4" fill="currentColor" stroke="none"></circle>
              <circle cx="12" cy="12" r="4"></circle>
              <circle cx="12" cy="12" r="7"></circle>
            </svg>
          </span>
        </button>
        <button class="view-toggle-btn floorplan-tool-btn icon-only" data-tool="zone" aria-label="Zone polygon tool" aria-pressed="false">
          <span class="btn-icon" aria-hidden="true">
            <svg viewBox="0 0 24 24">
              <circle cx="6" cy="6" r="2"></circle>
              <circle cx="18" cy="6" r="2"></circle>
              <circle cx="18" cy="18" r="2"></circle>
              <circle cx="6" cy="18" r="2"></circle>
              <path d="M8 6H16 M18 8V16 M16 18H8 M6 16V8"></path>
            </svg>
          </span>
        </button>
      </div>

      <div class="floorplan-history" id="floorplanHistory" style="display:none" aria-label="Floorplan history controls">
        <button class="view-toggle-btn icon-only" id="floorplanUndoBtn" aria-label="Undo">
          <span class="btn-icon" aria-hidden="true">
            <svg viewBox="0 0 24 24">
              <path d="M16 6 L8 12 L16 18 Z"></path>
            </svg>
          </span>
        </button>
        <button class="view-toggle-btn icon-only" id="floorplanRedoBtn" aria-label="Redo">
          <span class="btn-icon" aria-hidden="true">
            <svg viewBox="0 0 24 24">
              <path d="M8 6 L16 12 L8 18 Z"></path>
            </svg>
          </span>
        </button>
      </div>
      <div class="legend" id="legend">
        <button class="view-toggle-btn legend-btn" data-op="minus">−</button>
        <div class="legend-bar"></div>
        <button class="view-toggle-btn legend-btn" data-op="plus">+</button>
      </div>
    </div>
    <div id="panelCard" class="card panel">
      <div class="section">
        <div class="title" id="deviceTitle">Device</div>
        <div class="row"><select id="selDevices" aria-label="Device list" style="flex:1"></select></div>
      </div>
      <div class="section">
        <div class="title">Status</div>
        <div class="row">
          <div class="input-with-icon">
            <span id="sDot" class="dot status-icon ok" aria-hidden="true"></span>
            <input id="sText" class="status-input readonly" value="Ready" readonly />
          </div>
        </div>
      </div>
      <div class="section" id="floorplanDeviceSection" style="display:none">
        <div class="title">Device</div>
        <div class="row"><select id="floorplanDeviceSel" aria-label="Device list (floorplan)" style="flex:1"></select></div>
      </div>
      <div class="section">
        <div class="title" id="modeTitle">View Mode</div>
        <div class="row equal" id="viewControls">
          <button id="liveModeBtn" class="btn-primary">Live Targets</button>
          <select id="heatmapHoursSel" aria-label="Heatmap hours">
            <option value="1">1h</option><option value="3">3h</option><option value="6">6h</option>
            <option value="12">12h</option><option value="24" selected>24h</option>
          </select>
          <button id="heatmapModeBtn" class="btn-plain">Heatmap</button>
        </div>
        <div class="row equal" id="floorplanRangeControls" style="display:none">
          <input id="floorplanRangeInput" type="number" min="0" max="600" step="1" placeholder="0 – 600 cm" inputmode="numeric" />
          <button id="floorplanRangeSetBtn" class="btn-primary">Save</button>
        </div>
      </div>
      <div class="section" id="rangeSection">
        <div class="title">Detection range</div>
        <div class="row equal">
          <input id="rangeInput" type="number" min="0" max="600" step="1" placeholder="0 – 600 cm" inputmode="numeric" />
          <button id="rangeSetBtn" class="btn-primary">Save</button>
        </div>
      </div>
      <div class="section">
        <div class="title">Zones</div>
        <div class="zones">
          <button class="zone-btn btn-plain" data-zone="1">Zone 1</button>
          <button class="zone-btn btn-plain" data-zone="2">Zone 2</button>
          <button class="zone-btn btn-plain" data-zone="3">Zone 3</button>
          <button class="zone-btn btn-plain" data-zone="excl">Exclusion Zone</button>
        </div>
      </div>
      <div class="section">
        <div class="title">Actions</div>
        <div class="row equal">
          <button id="saveBtn" class="btn-primary">Save</button>
          <button id="clearBtn" class="btn-plain">Clear</button>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {

  const BASE_CANVAS_W=1200, BASE_PANEL_W=400, BASE_GAP=10, SWITCH_BREAKPOINT=1150;
  const $=id=>document.getElementById(id);
  const container=$('container'), canvasCard=$('canvasCard'), panelCard=$('panelCard');
  const cvs=$('canvas'), ctx=cvs.getContext('2d',{alpha:true,desynchronized:true});
  const sel=$('selDevices');
  const floorplanDeviceSection=$('floorplanDeviceSection');
  const floorplanDeviceSel=$('floorplanDeviceSel');
  const rangeSection=$('rangeSection');
  const deviceTitle=$('deviceTitle');
  const saveBtn=$('saveBtn'), clearBtn=$('clearBtn');
  const rangeInput=$('rangeInput'), rangeSetBtn=$('rangeSetBtn');
  const liveModeBtn=$('liveModeBtn'),
        heatmapModeBtn=$('heatmapModeBtn'),
        heatmapHoursSel=$('heatmapHoursSel');
  const floorplanRangeControls=$('floorplanRangeControls');
  const floorplanRangeInput=$('floorplanRangeInput');
  const floorplanRangeSetBtn=$('floorplanRangeSetBtn');
  const viewControls=$('viewControls');
  const modeTitle=$('modeTitle');
  const sDot=$('sDot'), sText=$('sText');
  const zoneBtns=[...document.querySelectorAll('.zone-btn')];
  const legend=$('legend');
  const viewToggle=$('viewToggle');
  const floorplanBtn=$('floorplanBtn');
  const floorplanTools=$('floorplanTools');
  const floorplanHistoryBar=$('floorplanHistory');
  const floorplanUndoBtn=$('floorplanUndoBtn');
  const floorplanRedoBtn=$('floorplanRedoBtn');
  const viewToggleBtns=[...document.querySelectorAll('.view-toggle-btn[data-view]')];
  const legendSigmaBtns=[...document.querySelectorAll('.legend-btn')];
  const floorplanToolBtns=[...document.querySelectorAll('.floorplan-tool-btn')];

  const X_MIN=-525, X_MAX=525, Y_MIN=0, Y_MAX=600;
  const WORLD_W = X_MAX - X_MIN;
  const WORLD_H = Y_MAX - Y_MIN;
  const MAX_RANGE=600, MAX_POINTS=8, FOV_DEG=120, GRID=100;
  const TOP_RANGE=400;
  const BASE_BOUNDS = {xMin:X_MIN, xMax:X_MAX, yMin:Y_MIN, yMax:Y_MAX};
  const TOP_BOUNDS = {xMin:-TOP_RANGE, xMax:TOP_RANGE, yMin:-TOP_RANGE, yMax:TOP_RANGE};
  const FLOORPLAN_SCALE = 6;
  const FLOORPLAN_INITIAL_SCALE = 2;
  const FLOORPLAN_W = WORLD_W * FLOORPLAN_SCALE;
  const FLOORPLAN_H = WORLD_H * FLOORPLAN_SCALE;
  const FLOORPLAN_INITIAL_W = WORLD_W * FLOORPLAN_INITIAL_SCALE;
  const FLOORPLAN_INITIAL_H = WORLD_H * FLOORPLAN_INITIAL_SCALE;
  const FLOORPLAN_CENTER_X = (X_MIN + X_MAX) * 0.5;
  const FLOORPLAN_CENTER_Y = (Y_MIN + Y_MAX) * 0.5;
  const FLOORPLAN_BOUNDS = {
    xMin: FLOORPLAN_CENTER_X - FLOORPLAN_W * 0.5,
    xMax: FLOORPLAN_CENTER_X + FLOORPLAN_W * 0.5,
    yMin: FLOORPLAN_CENTER_Y - FLOORPLAN_H * 0.5,
    yMax: FLOORPLAN_CENTER_Y + FLOORPLAN_H * 0.5
  };
  const FLOORPLAN_INITIAL_BOUNDS = {
    xMin: FLOORPLAN_CENTER_X - FLOORPLAN_INITIAL_W * 0.5,
    xMax: FLOORPLAN_CENTER_X + FLOORPLAN_INITIAL_W * 0.5,
    yMin: FLOORPLAN_CENTER_Y - FLOORPLAN_INITIAL_H * 0.5,
    yMax: FLOORPLAN_CENTER_Y + FLOORPLAN_INITIAL_H * 0.5
  };
  const FOV_RAD = FOV_DEG * Math.PI / 180;

  const WALL_HEIGHT_CM = 180;
  const FLOORPLAN_WALL_HEIGHT_CM = WALL_HEIGHT_CM * 1.3;
  const HEATMAP_MAX_HEIGHT_CM = 150;
  const HEATMAP3D_MAX_RES = 1024;

  const TUNE = {
    sigmaScale: 1.0,
    clipPercentile: 0.99,
    gamma: 0.5,
    minCutoff: 0.08,
    maxAlpha: 250,
    pointWeight: 0.5
  };

  const UI_STATE_KEY='zone-editor-ui-state';
  const normalizeViewDim=(v)=> (v==='3d' ? '3d' : '2d');
  const normalizeViewMode=(v)=> (v==='heatmap' ? 'heatmap' : 'live');

  function loadUiState(){
    try{
      if(typeof localStorage==='undefined') return null;
      const raw=localStorage.getItem(UI_STATE_KEY);
      if(!raw) return null;
      const parsed=JSON.parse(raw);
      return (parsed && typeof parsed==='object') ? parsed : null;
    }catch(_e){
      return null;
    }
  }

  function persistUiState(){
    try{
      if(typeof localStorage==='undefined') return;
      const next={
        viewDim,
        viewMode,
        floorplanEnabled,
        selectedFloorId,
        selectedDeviceId: selectedDevice?.device_id || floorplanDeviceSel?.value || null
      };
      localStorage.setItem(UI_STATE_KEY, JSON.stringify(next));
    }catch(_e){}
  }

  let initialUiState=null;

  let cssW=0, cssH=0, dpr=1, PAD=12;
  let currentZone=null;
  let zones={'1':[],'2':[],'3':[],'excl':[]};
  const makeLivePos=()=>({
    1: { x: NaN, y: NaN, px: NaN, py: NaN, heading: 0 },
    2: { x: NaN, y: NaN, px: NaN, py: NaN, heading: 0 },
    3: { x: NaN, y: NaN, px: NaN, py: NaN, heading: 0 },
    4: { x: NaN, y: NaN, px: NaN, py: NaN, heading: 0 },
    5: { x: NaN, y: NaN, px: NaN, py: NaN, heading: 0 }
  });
  const livePosMap={};
  let livePos=makeLivePos();
  function livePosFor(deviceId){
    const key=deviceId||'__default';
    if(!livePosMap[key]) livePosMap[key]=makeLivePos();
    return livePosMap[key];
  }
  let selectedDevice=null;
  let selectedFloorId=null;
  let devicesList=[];
  let floorsList=[];
  let entities=[], detRange=MAX_RANGE, saving=false;
  let installMode='side';
  let viewMode='live';
  let viewDim='2d';
  let floorplanEnabled=false;
  let floorplanPolylines=[];
  let floorplanActiveLine=null;
  let floorplanPreview=null;
  let floorplanPreviewDir={x:0,y:-1};
  let floorplanPreviewSuppressed=false;
  let floorplanLengthInput='';
  let floorplanEditEnabled=true;
  let floorplanTool='view';
  let floorplanSensors=[];
  let floorplanSensorHover=null;
  let floorplanSensorDragging=null;
  let floorplanSensorRotating=null;
  let floorplanDragMode=null;
  let floorplanHistory=[];
  let floorplanFuture=[];
  let floorplanZoneDragIdx=null, floorplanZoneDragWhole=false, floorplanZoneLastPX=0, floorplanZoneLastPY=0;
  let pan2DDragging=false, panLastX=0, panLastY=0;
  let heatmapPositions=[];
  let heatmapFieldColor=null, heatmapFieldHeight=null, heatmapFieldW=0, heatmapFieldH=0;
  let HUMAN_TRIANGLES=[];

  const DEFAULT_AZIMUTH = 0;
  const DEFAULT_ELEVATION = 40 * Math.PI / 180;
  const CAMERA_FOV_DEG = 60;
  const MIN_ZOOM_2D = 0.4;
  const MAX_ZOOM_2D = 4;

  const ORBIT = {
    azimuth: DEFAULT_AZIMUTH,
    elevation: DEFAULT_ELEVATION,
    distance: 1400
  };
  const ORBIT_TARGET = {x:0,z:0}; 
  const ORBIT_LIMITS = {
    minElev: -Math.PI * 0.05,
    maxElev: Math.PI * 0.9,
    minDist: 400,
    maxDist: 1125 * 1.5
  };
  const ORBIT_ROTATE_SPEED = 0.01;
  const ORBIT_PAN_SPEED = 0.0025;

  const DEFAULT_ORBIT_DIST = ((BASE_BOUNDS.yMax - BASE_BOUNDS.yMin) * 0.5) *
    (Math.cos(DEFAULT_ELEVATION) + (Math.sin(DEFAULT_ELEVATION) / Math.tan((CAMERA_FOV_DEG * Math.PI / 180) * 0.5)));

  const defaultOrbitDistance=(bounds=activeBounds())=>{
    const halfDepth = (bounds.yMax - bounds.yMin) * 0.5;
    const tanHalfFov = Math.tan((CAMERA_FOV_DEG * Math.PI / 180) * 0.5);
    const dist = halfDepth * (Math.cos(DEFAULT_ELEVATION) + (Math.sin(DEFAULT_ELEVATION) / tanHalfFov));
    return clamp(dist, ORBIT_LIMITS.minDist, ORBIT_LIMITS.maxDist);
  };

  function activeBounds(){
    return floorplanEnabled ? FLOORPLAN_BOUNDS : baseBounds();
  }

  function recenterOrbitTarget(bounds=activeBounds()){
    ORBIT_TARGET.x = (bounds.xMin + bounds.xMax) * 0.5;
    ORBIT_TARGET.z = (bounds.yMin + bounds.yMax) * 0.5;
  }

  function clampOrbitTarget(bounds=activeBounds()){
    const marginX = Math.max(40, (bounds.xMax - bounds.xMin) * 0.12);
    const marginZ = Math.max(40, (bounds.yMax - bounds.yMin) * 0.12);
    ORBIT_TARGET.x = clamp(ORBIT_TARGET.x, bounds.xMin - marginX, bounds.xMax + marginX);
    ORBIT_TARGET.z = clamp(ORBIT_TARGET.z, bounds.yMin - marginZ, bounds.yMax + marginZ);
  }

  function resetOrbit(dist=DEFAULT_ORBIT_DIST){
    recenterOrbitTarget();
    ORBIT.azimuth   = DEFAULT_AZIMUTH;
    ORBIT.elevation = DEFAULT_ELEVATION;
    ORBIT.distance  = clamp(dist, ORBIT_LIMITS.minDist, ORBIT_LIMITS.maxDist);
  }

  let floorplanWallsDirty=false;

  function markFloorplanWallsDirty(){
    floorplanWallsDirty=true;
  }

  function resetFloorplanOrbitFromInitialEdge(){
    const b = FLOORPLAN_INITIAL_BOUNDS;
    ORBIT_TARGET.x = (b.xMin + b.xMax) * 0.5;
    ORBIT_TARGET.z = (b.yMin + b.yMax) * 0.5;
    ORBIT.azimuth = 0;
    ORBIT.elevation = DEFAULT_ELEVATION;
    ORBIT.distance = defaultOrbitDistance(b);
  }

  const resetOrbitIf3D=()=>{
    if(viewDim !== '3d') return;
    if(floorplanEnabled) resetFloorplanOrbitFromInitialEdge();
    else resetOrbit(defaultOrbitDistance());
  };

  let orbitDragging=false, orbitLastX=0, orbitLastY=0, orbitDragMode='orbit';
  let pinchZooming=false, pinchLastDist=0;
  let touchMode=null;
  let resizeScheduled=false;

  const cam3D = {
    pos:{x:0,y:0,z:0},
    target:{x:0,y:0,z:0},
    cosA:0,sinA:0,cosE:0,sinE:0,
    scale:1,
    cx:0,cy:0,
    near:0.05,
    fovDeg:CAMERA_FOV_DEG,
    aspect:1
  };

  const BOOT_KEY='sensy_boot_reloaded_once';
  let liveTimer=null, livePauseDepth=0, liveInFlight=false;
  const LIVE_INTERVAL_MS=30;

  const cssVar=(n)=>getComputedStyle(document.documentElement).getPropertyValue(n).trim();
  const uiScale=()=>parseFloat(cssVar('--ui')||'1')||1;
  const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
  const fovMaxRange=(mode=installMode)=> (mode==='top' ? TOP_RANGE : MAX_RANGE);
  function baseBounds(){
    return installMode==='top' ? TOP_BOUNDS : BASE_BOUNDS;
  }
  function clampBaseX(v){
    const b=baseBounds();
    return clamp(v, b.xMin, b.xMax);
  }
  function clampBaseY(v){
    const b=baseBounds();
    return clamp(v, b.yMin, b.yMax);
  }
  const hairline=()=>1/Math.max(1,dpr);
  const alignPx=(v)=>Math.round(v)+0.5*hairline();
  const IS_MOBILE = matchMedia('(pointer: coarse)').matches || ('ontouchstart' in window && !matchMedia('(any-pointer: fine)').matches);
  const WALL_COLOR='rgba(185,194,207,0.9)';
  const WALL_FILL='rgba(185,194,207,0.14)';
  const WALL_HANDLE_SHADOW='rgba(0,0,0,0.4)';
  const HANDLE_RADIUS_PX = IS_MOBILE ? 5 * 0.7 : 4.2 * 0.85;
  function handleScale(){
    const base = IS_MOBILE ? 0.85 : 1;
    return base;
  }
  const wallStrokeWidth=()=>Math.max(1.3, hairline()*2.2) * handleScale();
  const wallHandleRadius=()=>HANDLE_RADIUS_PX;
  const wallStyle=()=>({stroke:WALL_COLOR,fill:WALL_FILL,fillAlpha:1,width:wallStrokeWidth()});

  const cam2D = {
    zoom:1,
    cx:(X_MIN+X_MAX)*0.5,
    cy:(Y_MIN+Y_MAX)*0.5
  };

  const camFP = {
    zoom:1,
    cx:(FLOORPLAN_BOUNDS.xMin+FLOORPLAN_BOUNDS.xMax)*0.5,
    cy:(FLOORPLAN_BOUNDS.yMin+FLOORPLAN_BOUNDS.yMax)*0.5
  };

  function reset2DCam(){
    cam2D.zoom=1;
    const b=baseBounds();
    cam2D.cx=(b.xMin+b.xMax)*0.5;
    cam2D.cy=(b.yMin+b.yMax)*0.5;
  }

  function resetFPCam(){
    fitFloorplanCamToBounds(FLOORPLAN_INITIAL_BOUNDS);
  }

  const activeCam=()=> floorplanEnabled ? camFP : cam2D;
  const activeBounds2D=()=> floorplanEnabled ? FLOORPLAN_BOUNDS : baseBounds();

  function clampCam(cam,bounds){
    const halfW = (bounds.xMax - bounds.xMin) * 0.55;
    const halfH = (bounds.yMax - bounds.yMin) * 0.55;
    cam.cx = clamp(cam.cx, bounds.xMin - halfW, bounds.xMax + halfW);
    cam.cy = clamp(cam.cy, bounds.yMin - halfH, bounds.yMax + halfH);
  }

  function smoothstep01(t){
    t = clamp(t,0,1);
    return t*t*(3-2*t);
  }

  function updateUIScale(){
    const isTwoCols=window.matchMedia('(min-width:1151px)').matches;
    if(!isTwoCols) document.documentElement.style.setProperty('--ui','1');
    else{
      const vw=Math.max(320,window.innerWidth), gutter=32;
      const available=vw-gutter, baseTotal=BASE_CANVAS_W+BASE_PANEL_W+BASE_GAP;
      const scale=Math.max(0.6,Math.min(1,available/baseTotal));
      document.documentElement.style.setProperty('--ui',String(scale));
    }
    const ui=parseFloat(cssVar('--ui')||'1')||1; PAD=Math.round(14*ui);
  }

  function stopLive(){
    if(liveTimer){
      clearInterval(liveTimer);
      liveTimer=null;
    }
  }

  function pauseLive(){
    livePauseDepth++;
    stopLive();
  }

  function resumeLive(force=false){
    if(force){
      livePauseDepth = 0;
    }else{
      livePauseDepth = Math.max(0, livePauseDepth - 1);
    }
    if(livePauseDepth===0 && selectedDevice && !liveTimer){
      liveTimer = setInterval(fetchTargets, LIVE_INTERVAL_MS);
    }
  }

  const pauseDuring=(fn)=>async(...a)=>{ pauseLive(); try{ return await fn(...a); } finally{ resumeLive(); } };

  let statusResetTimer=null;
  function setStatusText(text){
    if(statusResetTimer){
      clearTimeout(statusResetTimer);
      statusResetTimer=null;
    }
    sDot.className='dot status-icon ok';
    sText.value=text||'Ready';
  }

  function scheduleStatusReady(){
    if(statusResetTimer) clearTimeout(statusResetTimer);
    statusResetTimer=setTimeout(()=>{
      statusResetTimer=null;
      sDot.className='dot status-icon ok';
      sText.value='Ready';
    }, 1200);
  }

  function setReady() {
    setStatusText('Ready');
  }

  function setLoadingHeatmap() {
    setStatusText('Loading heatmap…');
  }

  function setSaved() {
    setStatusText('Saved');
    scheduleStatusReady();
  }

  function setCleared() {
    setStatusText('Cleared');
    scheduleStatusReady();
  }

  function reportError(msg){
    if(msg) console.error(msg);
  }

  function populateDevices(list, selectedId, targetSel=sel){
    if(!targetSel) return;
    targetSel.innerHTML='';
    list.sort((a,b)=>(a.name||a.device_id).localeCompare(b.name||b.device_id))
      .forEach((d,i)=>{
        const opt=document.createElement('option');
        opt.value=d.device_id;
        opt.textContent=d.name||d.device_id;
        opt.dataset.model=d.model||'';
        if(selectedId ? d.device_id===selectedId : i===0) opt.selected=true;
        targetSel.appendChild(opt);
      });
  }

  function populateFloors(list, selectedId){
    sel.innerHTML='';
    list.sort((a,b)=>(a.name||a.floor_id).localeCompare(b.name||b.floor_id))
      .forEach((f,i)=>{
        const opt=document.createElement('option');
        opt.value=f.floor_id;
        opt.textContent=f.name||f.floor_id;
        opt.dataset.icon=f.icon||'';
        if(selectedId ? f.floor_id===selectedId : i===0) opt.selected=true;
        sel.appendChild(opt);
      });
  }

  async function api(path, body, {retryOnError=true, reloadOnError=true}={}){
    try{
      const r=await fetch(path,{
        method:'POST',
        headers:{'Content-Type':'application/json'},
        credentials:'include',
        body:JSON.stringify(body||{})
      });
      const text=await r.text();
      if(!r.ok){
        if((r.status===500||r.status===502)&&retryOnError){
          await new Promise(res=>setTimeout(res,200));
          return api(path,body,{retryOnError:false,reloadOnError});
        }
        if((r.status===500||r.status===502)&&reloadOnError&&!localStorage.getItem(BOOT_KEY)){
          localStorage.setItem(BOOT_KEY,'1');
          location.reload();
          await new Promise(()=>{});
        }
        let msg=r.status+' '+r.statusText;
        try{
          const j=JSON.parse(text);
          msg=(j.error||msg)+(j.details?` (${j.details})`:'');
        }catch{}
        throw new Error(msg);
      }
      localStorage.removeItem(BOOT_KEY);
      const ct=r.headers.get('content-type')||'';
      if(ct.includes('application/json')){
        try{
          return JSON.parse(text);
        }catch(e){
          throw new Error('JSON parse error: '+(e.message||e)+'. Body: '+text.slice(0,200));
        }
      }
      return text;
      }catch(err){
      if(reloadOnError && err instanceof TypeError && !localStorage.getItem(BOOT_KEY)){
        localStorage.setItem(BOOT_KEY,'1');
        location.reload();
        await new Promise(()=>{});
      }
      throw err;
    }
  }

  const TPL_LIST=`
{% set out = namespace(items=[], ids=[]) %}
{% for s in states %}
  {% set dev = s.entity_id | device_id %}
  {% if dev and (device_attr(dev,'manufacturer') or '') == 'Sensy-One' and (dev not in out.ids) %}
    {% set name = device_attr(dev,'name_by_user') or device_attr(dev,'name') or dev %}
    {% set model = device_attr(dev,'model') or '' %}
    {% set out.items = out.items + [ { 'device_id': dev, 'name': name, 'model': model } ] %}
    {% set out.ids = out.ids + [ dev ] %}
  {% endif %}
{% endfor %}
{{ out.items | tojson }}
  `.trim();

  const targetsTemplate=(devId)=>(`
{% set dev = '`+devId+`' %}
{% set out = namespace(
  x1=0.0,y1=0.0,a1=0.0,
  x2=0.0,y2=0.0,a2=0.0,
  x3=0.0,y3=0.0,a3=0.0,
  x4=0.0,y4=0.0,a4=0.0,
  x5=0.0,y5=0.0,a5=0.0
) %}
{% for s in states if (s.entity_id | device_id) == dev %}
  {% set id = s.entity_id %}
  {% if id.endswith('target_1_x') %}{% set out.x1 = (s.state | float(0)) %}{% endif %}
  {% if id.endswith('target_1_y') %}{% set out.y1 = (s.state | float(0)) %}{% endif %}
  {% if id.endswith('target_1_angle') %}{% set out.a1 = (s.state | float(0)) %}{% endif %}

  {% if id.endswith('target_2_x') %}{% set out.x2 = (s.state | float(0)) %}{% endif %}
  {% if id.endswith('target_2_y') %}{% set out.y2 = (s.state | float(0)) %}{% endif %}
  {% if id.endswith('target_2_angle') %}{% set out.a2 = (s.state | float(0)) %}{% endif %}

  {% if id.endswith('target_3_x') %}{% set out.x3 = (s.state | float(0)) %}{% endif %}
  {% if id.endswith('target_3_y') %}{% set out.y3 = (s.state | float(0)) %}{% endif %}
  {% if id.endswith('target_3_angle') %}{% set out.a3 = (s.state | float(0)) %}{% endif %}

  {% if id.endswith('target_4_x') %}{% set out.x4 = (s.state | float(0)) %}{% endif %}
  {% if id.endswith('target_4_y') %}{% set out.y4 = (s.state | float(0)) %}{% endif %}
  {% if id.endswith('target_4_angle') %}{% set out.a4 = (s.state | float(0)) %}{% endif %}

  {% if id.endswith('target_5_x') %}{% set out.x5 = (s.state | float(0)) %}{% endif %}
  {% if id.endswith('target_5_y') %}{% set out.y5 = (s.state | float(0)) %}{% endif %}
  {% if id.endswith('target_5_angle') %}{% set out.a5 = (s.state | float(0)) %}{% endif %}
{% endfor %}
{{ {
  '1': {'x': out.x1, 'y': out.y1, 'angle': out.a1},
  '2': {'x': out.x2, 'y': out.y2, 'angle': out.a2},
  '3': {'x': out.x3, 'y': out.y3, 'angle': out.a3},
  '4': {'x': out.x4, 'y': out.y4, 'angle': out.a4},
  '5': {'x': out.x5, 'y': out.y5, 'angle': out.a5}
} | tojson }}
`.trim());

  async function fetchTargetsForDevice(deviceId){
    const tpl=targetsTemplate(deviceId);
    const res=await api('api/template',{template:tpl},{retryOnError:false,reloadOnError:false});
    const obj=(typeof res==='string')?JSON.parse(res||'{}'):res;
    const lpMap = livePosFor(deviceId);
    let changed=false;
    for (const n of [1, 2, 3, 4, 5]) {
      const item = obj?.[String(n)] || {};
      const x = Number(item.x);
      const y = Number(item.y);

      const lp = lpMap[n];
      const prevX = lp.x;
      const prevY = lp.y;

      if (Number.isFinite(x) && x !== lp.x) {
        lp.x = x;
        changed = true;
      }
      if (Number.isFinite(y) && y !== lp.y) {
        lp.y = y;
        changed = true;
      }

      if (
        Number.isFinite(prevX) && Number.isFinite(prevY) &&
        Number.isFinite(lp.x) && Number.isFinite(lp.y)
      ) {
        const dx = lp.x - prevX;
        const dz = lp.y - prevY;

        const dist2 = dx * dx + dz * dz;
        if (dist2 > 5) {
          lp.heading = Math.atan2(dx, dz);
        }
      }

      lp.px = prevX;
      lp.py = prevY;
    }
    return changed;
  }

  async function fetchTargets(){
    if(liveInFlight || document.visibilityState==='hidden') return;
    const devIds=new Set();
    if(selectedDevice?.device_id) devIds.add(selectedDevice.device_id);
    if(floorplanEnabled){
      floorplanSensors.forEach(s=>{ if(s.device_id) devIds.add(s.device_id); });
    }
    if(!devIds.size && selectedDevice?.device_id) devIds.add(selectedDevice.device_id);
    if(!devIds.size) return;
    liveInFlight=true;
    try{
      let changedAny=false;
      for(const devId of devIds){
        const changed = await fetchTargetsForDevice(devId);
        if(changed) changedAny=true;
      }
      if(changedAny) enqueueDraw();
    }catch(_e){} finally{ liveInFlight=false; }
  }

  function findEntityIdBySuffix(suffix){
    return (entities.find(x=>x.entity_id.endsWith(suffix))?.entity_id)||null;
  }
  function detectInstallMode(){
    const match=entities.find(x=>x.entity_id.includes('radar_installation_method'));
    const state=(match?.state ?? '').toString().trim().toLowerCase();
    return (state==='top' || state==='side') ? state : 'side';
  }
  function readNumberBySuffix(suffix){
    const e=entities.find(x=>x.entity_id.endsWith(suffix));
    if(!e) return null;
    const v=(typeof e.state==='number')?e.state:Number(e.state);
    return Number.isFinite(v)?v:null;
  }
  async function setNumberBySuffix(suffix,value){
    const id=findEntityIdBySuffix(suffix);
    if(!id) throw new Error('Entity not found: *'+suffix);
    await api('api/services/number/set_value',{entity_id:id,value});
    const e=entities.find(x=>x.entity_id===id);
    if(e) e.state=String(value);
  }

  function zid(z){
    if(z==='excl'){
      return {
        label:'Exclusion Zone',
        count:'exclusion_zone_points_count',
        x:(i)=>`exclusion_zone_p${i}_x`,
        y:(i)=>`exclusion_zone_p${i}_y`
      };
    }
    return {
      label:`Zone ${z}`,
      count:`zone_${z}_points_count`,
      x:(i)=>`zone_${z}_p${i}_x`,
      y:(i)=>`zone_${z}_p${i}_y`
    };
  }
  async function loadDeviceEntitiesCore(device_id){
    const rows=await api('api/device_entities',{device_id},{reloadOnError:false});
    const arr=Array.isArray(rows)?rows:JSON.parse(rows||'[]');
    entities=arr.map(e=>({entity_id:e.entity_id,domain:e.domain,state:e.state,attributes:e.attributes||{}}));
    const nextMode = detectInstallMode();
    if(selectedDevice?.device_id === device_id){
      if(nextMode !== installMode){
        installMode = nextMode;
        heatmapFieldColor=null;
        heatmapFieldHeight=null;
        heatmapFieldW=0;
        heatmapFieldH=0;
        if(!floorplanEnabled && viewDim === '2d') reset2DCam();
        enqueueDraw();
      }else{
        installMode = nextMode;
      }
    }
  }

  async function loadFloorsCore(){
    const r=await fetch('api/floors',{method:'GET',credentials:'include'});
    const text=await r.text();
    if(!r.ok){
      let msg=r.status+' '+r.statusText;
      try{
        const j=JSON.parse(text);
        msg=(j.error||msg)+(j.details?` (${j.details})`:'');
      }catch{}
      throw new Error(msg);
    }
    let res=text;
    const ct=r.headers.get('content-type')||'';
    if(ct.includes('application/json')){
      try{ res=text?JSON.parse(text):[]; }catch(e){ throw new Error('JSON parse error: '+(e.message||e)); }
    }else if(typeof res==='string'){
      try{ res=JSON.parse(res||'[]'); }catch{}
    }
    const arr=Array.isArray(res)?res:[];
    floorsList=arr.map(f=>{
      if(typeof f==='string') return {floor_id:f,name:f,icon:''};
      return {floor_id:f.floor_id||f.id||'', name:f.name||f.floor_id||f.id||'', icon:f.icon||''};
    }).filter(f=>f.floor_id);
    if(floorsList.length){
      populateFloors(floorsList, selectedFloorId);
      selectedFloorId = sel.value || selectedFloorId || (floorsList[0]?.floor_id ?? null);
    }
  }

  function syncFloorplanDeviceSelector(){
    if(!floorplanDeviceSel) return;
    populateDevices(devicesList, selectedDevice?.device_id, floorplanDeviceSel);
  }

  function selectedDeviceFromSelect(selectEl){
    if(!selectEl || !selectEl.value) return null;
    const opt=selectEl.options[selectEl.selectedIndex] || selectEl.options[0];
    if(!opt || !opt.value) return null;
    return {
      device_id: opt.value,
      name: opt.textContent || opt.value,
      model: opt.dataset.model || ''
    };
  }

  function placementDevice(){
    return selectedDeviceFromSelect(floorplanDeviceSel) || selectedDeviceFromSelect(sel) || selectedDevice || null;
  }

  const sensorAngle=(s)=> (s && Number.isFinite(s.angle)) ? s.angle : 0;
  function normalizeInstallModeValue(raw){
    const val=(raw ?? '').toString().trim().toLowerCase();
    return (val==='top' || val==='side') ? val : null;
  }
  function sensorInstallMode(sensor){
    return normalizeInstallModeValue(
      sensor?.install_mode ?? sensor?.installMode ?? sensor?.mount_mode ?? sensor?.mountMode ?? sensor?.mode
    ) || 'side';
  }
  function clampFovRange(range, mode){
    const maxR=fovMaxRange(mode);
    return Math.max(0, Math.min(maxR, range|0));
  }
  const sensorFovRange=(sensor, mode)=> clampFovRange(sensorDetRange(sensor), mode);
  const cloneZones=(src)=>({
    '1':[...(src?.['1']||[])].map(p=>({x:p.x,y:p.y})),
    '2':[...(src?.['2']||[])].map(p=>({x:p.x,y:p.y})),
    '3':[...(src?.['3']||[])].map(p=>({x:p.x,y:p.y})),
    'excl':[...(src?.['excl']||[])].map(p=>({x:p.x,y:p.y}))
  });
  const makeSensor=(x,y,dev)=>{
    const mode = dev?.device_id===selectedDevice?.device_id ? normalizeInstallModeValue(installMode) : null;
    const sensor={
      x,y,
      angle:0,
      device_id:dev?.device_id||'',
      name:dev?.name||'',
      model:dev?.model||'',
      detRange: detRange,
      zones: cloneZones(zones)
    };
    if(mode) sensor.install_mode = mode;
    return sensor;
  };
  const sensorDetRange=(s)=>{
    const raw=Number(s?.detRange ?? s?.det_range ?? s?.detection_range ?? s?.detection_range_cm);
    return Number.isFinite(raw) ? raw : 0;
  };
  const emptyZones=()=>({'1':[],'2':[],'3':[],'excl':[]});
  const sensorZones=(s)=> (s?.zones || emptyZones());
  const clampSensorPos=(s)=>{
    const cloned = {...s};
    cloned.x=clamp(Number(s.x)||0,FLOORPLAN_BOUNDS.xMin,FLOORPLAN_BOUNDS.xMax);
    cloned.y=clamp(Number(s.y)||0,FLOORPLAN_BOUNDS.yMin,FLOORPLAN_BOUNDS.yMax);
    cloned.angle=Number(s.angle)||0;
    if(Number.isFinite(Number(s.detRange))){
      cloned.detRange=clamp(Number(s.detRange),Y_MIN,MAX_RANGE);
    }
    const rawMode=normalizeInstallModeValue(
      s?.install_mode ?? s?.installMode ?? s?.mount_mode ?? s?.mountMode ?? s?.mode
    );
    if(rawMode) cloned.install_mode=rawMode;
    cloned.zones = cloneZones(s.zones||emptyZones());
    return cloned;
  };

  function adoptZonesFromSensor(sensor){
    if(!sensor) return;
    zones = cloneZones(sensor.zones || zones);
    if(Number.isFinite(sensor.detRange)){
      detRange = clamp(sensor.detRange, Y_MIN, MAX_RANGE);
      syncRangeInputs(detRange);
    }
    enqueueDraw();
  }

  function clearZoneSelection(){
    currentZone=null;
    zoneBtns.forEach(b=>b.classList.remove('active'));
  }

  function deselectZonesUI(){
    clearZoneSelection();
    dragIdx=null;
    dragWhole=false;
  }

  function selectSensorContext(sensor){
    if(!sensor || !sensor.device_id) return;
    selectedDevice={device_id:sensor.device_id,name:sensor.name||sensor.device_id,model:sensor.model||''};
    adoptZonesFromSensor(sensor);
    clearZoneSelection();
  }

  function updateModeSections(){
    if(rangeSection){
      rangeSection.style.display = floorplanEnabled ? 'none' : '';
    }
    if(floorplanDeviceSection){
      floorplanDeviceSection.style.display = floorplanEnabled ? '' : 'none';
      if(floorplanEnabled) syncFloorplanDeviceSelector();
    }
  }

  function showDeviceSelector(){
    if(floorplanEnabled){
      deviceTitle.textContent='Floor';
      sel.setAttribute('aria-label','Floor list');
      if(floorsList.length){
        populateFloors(floorsList, selectedFloorId);
        selectedFloorId = sel.value || selectedFloorId || (floorsList[0]?.floor_id ?? null);
      }else{
        sel.innerHTML='';
      }
      syncFloorplanDeviceSelector();
      updateModeSections();
      return;
    }
    deviceTitle.textContent='Device';
    sel.setAttribute('aria-label','Device list');
    if(devicesList.length){
      populateDevices(devicesList, selectedDevice?.device_id);
      const val=sel.value;
      if(val){
        const entry=devicesList.find(d=>d.device_id===val);
        selectedDevice = entry
          ? {device_id:entry.device_id,name:entry.name||entry.device_id,model:entry.model||''}
          : {device_id:val,name:val,model:''};
      }
    }else{
      sel.innerHTML='';
    }
    syncFloorplanDeviceSelector();
    updateModeSections();
  }

  const activeRangeInput=()=> (floorplanEnabled && floorplanRangeInput) ? floorplanRangeInput : rangeInput;
  function syncRangeInputs(val){
    if(rangeInput) rangeInput.value=String(val);
    if(floorplanRangeInput) floorplanRangeInput.value=String(val);
  }

  async function loadDetectionRangeCore(){
    let v=null;
    for(const suffix of rangeSuffixesForMode()){
      v=readNumberBySuffix(suffix);
      if(v!==null) break;
    }
    detRange=Math.round(Math.max(Y_MIN,Math.min(MAX_RANGE,v??MAX_RANGE)));
    syncRangeInputs(detRange);
  }

  function rangeSuffixesForMode(mode=installMode){
    const radarSuffix = mode === 'top' ? 'radar_top_range' : 'radar_side_range';
    return [radarSuffix, 'detection_range_cm', 'detection_range'];
  }

  function resolveRangeSuffix(){
    const suffixes = rangeSuffixesForMode();
    for(const suffix of suffixes){
      if(findEntityIdBySuffix(suffix)) return suffix;
    }
    return null;
  }

  async function setDetectionRangeCore(inputEl=activeRangeInput()){
    const src=inputEl||activeRangeInput();
    let val=Math.round(Number(src?.value));
    if(!Number.isFinite(val)){
      return;
    }
    val=Math.max(Y_MIN,Math.min(MAX_RANGE,val));
    try{
      const suffix = resolveRangeSuffix();
      if(!suffix) throw new Error('Range entity not found');
      await setNumberBySuffix(suffix,val);
      detRange=val;
      syncRangeInputs(val);
      syncActiveSensorState();
      setSaved();
      enqueueDraw();
    }catch(e){
      reportError(e?.message || 'Save failed');
    }
  }

  async function loadZoneCore(z){
    const id=zid(z);
    const n=Math.max(0,Math.min(MAX_POINTS,Math.round(readNumberBySuffix(id.count)||0)));
    const pts=[];
    for(let i=1;i<=n;i++){
      const x=readNumberBySuffix(id.x(i));
      const y=readNumberBySuffix(id.y(i));
      pts.push({
        x: Number.isFinite(x) ? x : 0,
        y: Number.isFinite(y) ? y : 0
      });
    }
    zones[z]=pts;
  }

  async function loadAllCore(){
    if(!selectedDevice){
      reportError('No data available');
      return;
    }
    await loadDetectionRangeCore();
    for(const z of ['1','2','3','excl']) await loadZoneCore(z);
    enqueueDraw();
  }

  async function fetchZonesFromDevice(dev){
    const target = dev || selectedDevice;
    if(!target || !target.device_id){
      reportError('No data available');
      return false;
    }
    selectedDevice={
      device_id: target.device_id,
      name: target.name || target.device_id,
      model: target.model || ''
    };
    await loadDeviceEntities(target.device_id);
    await loadAll();
    const sensorIdx = floorplanSensors.findIndex(s=>s.device_id===selectedDevice.device_id);
    if(sensorIdx>=0){
      floorplanSensors[sensorIdx]=clampSensorPos({
        ...floorplanSensors[sensorIdx],
        detRange: detRange,
        zones: cloneZones(zones)
      });
    }
    return true;
  }

  async function saveCurrentZoneCore(){
    if(saving) return;
    if(!selectedDevice){
      reportError('Save failed');
      return;
    }
    if(!currentZone){
      return;
    }
    const id=zid(currentZone);
    const pts=zones[currentZone]||[];
    const n=Math.min(MAX_POINTS,pts.length);
    try{
      saving=true;
      saveBtn.disabled=true;
      const tasks=[];
      for(let i=1;i<=MAX_POINTS;i++){
        const p=pts[i-1]||{x:0,y:0};
        const x=Number.isFinite(p.x) ? p.x : 0;
        const y=Number.isFinite(p.y) ? p.y : 0;
        tasks.push(setNumberBySuffix(id.x(i),x));
        tasks.push(setNumberBySuffix(id.y(i),y));
      }
      await Promise.allSettled(tasks);
      await setNumberBySuffix(id.count,n);
      setSaved();
      await loadZoneCore(currentZone);
      enqueueDraw();
    }catch(e){
      reportError(e?.message || 'Save failed');
    }finally{
      saving=false;
      saveBtn.disabled=false;
    }
  }

  async function saveAllZonesForSelectedDevice(){
    if(saving) return;
    if(!selectedDevice){
      reportError('Save failed');
      return;
    }
    const tasks=[];
    try{
      saving=true;
      saveBtn.disabled=true;
      for(const z of ['1','2','3','excl']){
        const id=zid(z);
        const pts=zones[z]||[];
        const n=Math.min(MAX_POINTS,pts.length);
        for(let i=1;i<=MAX_POINTS;i++){
          const p=pts[i-1]||{x:0,y:0};
          const x=Number.isFinite(p.x) ? p.x : 0;
          const y=Number.isFinite(p.y) ? p.y : 0;
          tasks.push(setNumberBySuffix(id.x(i),x));
          tasks.push(setNumberBySuffix(id.y(i),y));
        }
        tasks.push(setNumberBySuffix(id.count,n));
      }
      await Promise.allSettled(tasks);
      setSaved();
      deselectZonesUI();
    }catch(e){
      reportError(e?.message || 'Save failed');
    }finally{
      saving=false;
      saveBtn.disabled=false;
    }
  }

  async function saveAllZonesForDevice(deviceId, zonesToSave){
    if(!deviceId) return;
    await loadDeviceEntitiesCore(deviceId);
    const tasks=[];
    const srcZones = cloneZones(zonesToSave || {});
    for(const z of ['1','2','3','excl']){
      const id=zid(z);
      const pts=srcZones[z]||[];
      const n=Math.min(MAX_POINTS,pts.length);
      for(let i=1;i<=MAX_POINTS;i++){
        const p=pts[i-1]||{x:0,y:0};
        const x=Number.isFinite(p.x) ? p.x : 0;
        const y=Number.isFinite(p.y) ? p.y : 0;
        tasks.push(setNumberBySuffix(id.x(i),x));
        tasks.push(setNumberBySuffix(id.y(i),y));
      }
      tasks.push(setNumberBySuffix(id.count,n));
    }
    await Promise.allSettled(tasks);
  }

  async function saveAllFloorplanSensorZones(){
    let ok = true;
    if(saving) return false;
    const sensors = floorplanSensors.filter(s=>s.device_id);
    if(!sensors.length){
      if(selectedDevice?.device_id){
        saving=true;
        saveBtn.disabled=true;
        try{
          await saveAllZonesForDevice(selectedDevice.device_id, zones);
        }catch(e){
          reportError(e?.message || 'Save failed');
          ok = false;
        }finally{
          saving=false;
          saveBtn.disabled=false;
        }
      }
      return ok;
    }

    const unique=new Map();
    sensors.forEach(s=>{
      if(!unique.has(s.device_id)) unique.set(s.device_id,s);
    });
    const restoreDeviceId=selectedDevice?.device_id;
    saving=true;
    saveBtn.disabled=true;
    try{
      for(const sensor of unique.values()){
        await saveAllZonesForDevice(sensor.device_id, sensor.zones || {});
      }
    }catch(e){
      reportError(e?.message || 'Save failed');
      ok = false;
    }finally{
      saving=false;
      saveBtn.disabled=false;
      if(restoreDeviceId) await loadDeviceEntitiesCore(restoreDeviceId);
    }
    return ok;
  }

  function parsePx(v){ return Number((v||'0').toString().replace('px',''))||0; }
  function getCardPaddings(el){
    const cs=getComputedStyle(el);
    return {
      pt:parsePx(cs.paddingTop),
      pb:parsePx(cs.paddingBottom),
      pl:parsePx(cs.paddingLeft),
      pr:parsePx(cs.paddingRight)
    };
  }

  function resizeCanvas(){
    const twoCols=matchMedia(`(min-width:${SWITCH_BREAKPOINT+1}px)`).matches;
    const cardRect=canvasCard.getBoundingClientRect();
    const pad=getCardPaddings(canvasCard);
    if(twoCols){
      const panelH=Math.max(200,Math.round(panelCard.getBoundingClientRect().height));
      const targetCssH=Math.max(2,panelH-(pad.pt+pad.pb));
      let targetCssW=Math.round(targetCssH*(WORLD_W/WORLD_H));
      const maxCssW=Math.max(200,Math.round(cardRect.width-(pad.pl+pad.pr)));
      if(targetCssW>maxCssW){
        targetCssW=maxCssW;
        const cappedCssH=Math.round(targetCssW*(WORLD_H/WORLD_W));
        cssW=targetCssW;
        cssH=cappedCssH;
      }else{
        cssW=targetCssW;
        cssH=targetCssH;
      }
    }else{
      const maxCssW=Math.max(200,Math.round(cardRect.width-(pad.pl+pad.pr)));
      cssW=maxCssW;
      cssH=Math.round(cssW*(WORLD_H/WORLD_W));
    }
    const styleW=cssW+'px', styleH=cssH+'px';
    if(cvs.style.width!==styleW) cvs.style.width=styleW;
    if(cvs.style.height!==styleH) cvs.style.height=styleH;
    dpr=Math.max(1,window.devicePixelRatio||1);
    const devW=Math.max(2,Math.round(cssW*dpr)), devH=Math.max(2,Math.round(cssH*dpr));
    if(cvs.width!==devW) cvs.width=devW;
    if(cvs.height!==devH) cvs.height=devH;
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.imageSmoothingEnabled=false;
  }

  function syncLayout(){
    updateUIScale();
    resizeCanvas();
    heatmapFieldColor=null;
    heatmapFieldHeight=null;
    enqueueDraw();
  }

  function innerW(){ return Math.max(2,cssW-2*PAD); }
  function innerH(){ return Math.max(2,cssH-2*PAD); }
  const baseScaleX = ()=>{
    const b = baseBounds();
    const worldW = b.xMax - b.xMin;
    const worldH = b.yMax - b.yMin;
    if(installMode==='top'){
      return Math.min(innerW()/worldW, innerH()/worldH);
    }
    return innerW()/worldW;
  };
  const baseScaleY = ()=>{
    const b = baseBounds();
    const worldW = b.xMax - b.xMin;
    const worldH = b.yMax - b.yMin;
    if(installMode==='top'){
      return Math.min(innerW()/worldW, innerH()/worldH);
    }
    return innerH()/worldH;
  };
  const fpBaseScaleX = ()=>innerW()/FLOORPLAN_W;
  const fpBaseScaleY = ()=>innerH()/FLOORPLAN_H;

  function fitFloorplanCamToBounds(bounds){
    const boundsW = Math.max(1e-6, bounds.xMax - bounds.xMin);
    const boundsH = Math.max(1e-6, bounds.yMax - bounds.yMin);
    const zoomX = innerW() / (boundsW * fpBaseScaleX());
    const zoomY = innerH() / (boundsH * fpBaseScaleY());
    camFP.zoom = clamp(Math.min(zoomX, zoomY), MIN_ZOOM_2D, MAX_ZOOM_2D);
    camFP.cx = (bounds.xMin + bounds.xMax) * 0.5;
    camFP.cy = (bounds.yMin + bounds.yMax) * 0.5;
    clampCam(camFP, FLOORPLAN_BOUNDS);
  }

  function floorplanMinZoomToFit(){
    const b = FLOORPLAN_BOUNDS;
    const w = b.xMax - b.xMin;
    const h = b.yMax - b.yMin;
    const zx = innerW() / (w * fpBaseScaleX());
    const zy = innerH() / (h * fpBaseScaleY());
    const z = Math.min(zx, zy);
    return (Number.isFinite(z) && z > 0) ? z : 0.1;
  }

  function getFloorplanWallsBounds(){
    let xMin=Infinity, xMax=-Infinity, yMin=Infinity, yMax=-Infinity;
    let hasSegments=false;
    for(const line of floorplanPolylines){
      if(!line || line.length<2) continue;
      hasSegments=true;
      for(const p of line){
        const x=Number(p?.x);
        const y=Number(p?.y);
        if(!Number.isFinite(x) || !Number.isFinite(y)) continue;
        xMin=Math.min(xMin,x);
        xMax=Math.max(xMax,x);
        yMin=Math.min(yMin,y);
        yMax=Math.max(yMax,y);
      }
    }
    if(!hasSegments || !Number.isFinite(xMin)) return null;
    let cx = (xMin + xMax) * 0.5;
    let cy = (yMin + yMax) * 0.5;
    let w = xMax - xMin;
    let h = yMax - yMin;
    const minSize = 1;
    if(w < minSize){
      w = minSize;
      xMin = cx - w * 0.5;
      xMax = cx + w * 0.5;
    }
    if(h < minSize){
      h = minSize;
      yMin = cy - h * 0.5;
      yMax = cy + h * 0.5;
    }
    cx = (xMin + xMax) * 0.5;
    cy = (yMin + yMax) * 0.5;
    return {xMin,xMax,yMin,yMax,cx,cy,w,h};
  }

  function padFloorplanBounds(bounds){
    if(!bounds) return null;
    const pad = Math.max(80, 0.15 * Math.max(bounds.w, bounds.h));
    const xMin = bounds.xMin - pad;
    const xMax = bounds.xMax + pad;
    const yMin = bounds.yMin - pad;
    const yMax = bounds.yMax + pad;
    const w = (bounds.w + pad * 2);
    const h = (bounds.h + pad * 2);
    const cx = (xMin + xMax) * 0.5;
    const cy = (yMin + yMax) * 0.5;
    return {xMin,xMax,yMin,yMax,cx,cy,w,h};
  }

  function floorplanOrbitDistanceForBounds(bounds){
    const width = Number.isFinite(bounds?.w) ? bounds.w : (bounds.xMax - bounds.xMin);
    const height = Number.isFinite(bounds?.h) ? bounds.h : (bounds.yMax - bounds.yMin);
    const maxDim = Math.max(width || 0, height || 0);
    const halfDepth = Math.max(1e-6, maxDim * 0.5);
    const tanHalfFov = Math.tan((CAMERA_FOV_DEG * Math.PI / 180) * 0.5);
    const dist = halfDepth * (Math.cos(DEFAULT_ELEVATION) + (Math.sin(DEFAULT_ELEVATION) / tanHalfFov));
    return clamp(dist, ORBIT_LIMITS.minDist, ORBIT_LIMITS.maxDist);
  }

  function shouldAutoFitFloorplanNow(){
    if(!floorplanEnabled) return false;
    if(floorplanTool === 'draw') return false;
    if(floorplanActiveLine !== null) return false;
    if(floorplanPreview) return false;
    if(floorplanDragMode) return false;
    return true;
  }

  function zoomAllowed(){
    return floorplanEnabled === true;
  }

  function fitFloorplan2DToBounds(bounds){
    if(!bounds){
      resetFPCam();
      return;
    }
    const padded = padFloorplanBounds(bounds);
    fitFloorplanCamToBounds(padded);
  }

  function fitFloorplan3DToBounds(bounds, {resetAngles=false}={}){
    if(!bounds){
      resetFloorplanOrbitFromInitialEdge();
      return;
    }
    const padded = padFloorplanBounds(bounds);
    ORBIT_TARGET.x = padded.cx;
    ORBIT_TARGET.z = padded.cy;
    if(resetAngles){
      ORBIT.azimuth = DEFAULT_AZIMUTH;
      ORBIT.elevation = DEFAULT_ELEVATION;
    }
    ORBIT.distance = floorplanOrbitDistanceForBounds(padded);
  }

  function applyFloorplanAutoFit({resetAngles=false}={}){
    if(!shouldAutoFitFloorplanNow()) return;
    const bounds = getFloorplanWallsBounds();
    if(viewDim === '2d') fitFloorplan2DToBounds(bounds);
    else fitFloorplan3DToBounds(bounds, {resetAngles});
  }

  function applyFloorplanAutoFitIfDirty(){
    if(!floorplanWallsDirty) return;
    floorplanWallsDirty=false;
    applyFloorplanAutoFit();
  }

  function toPxX(x){
    return PAD + innerW()*0.5 + (x - cam2D.cx) * baseScaleX() * cam2D.zoom;
  }
  function toPxY(y){
    return PAD + innerH()*0.5 + (y - cam2D.cy) * baseScaleY() * cam2D.zoom;
  }
  function toCmX(px){
    return cam2D.cx + ((px - PAD - innerW()*0.5) / (baseScaleX()*cam2D.zoom));
  }
  function toCmY(py){
    return cam2D.cy + ((py - PAD - innerH()*0.5) / (baseScaleY()*cam2D.zoom));
  }

  function fpToPxX(x){
    return PAD + innerW()*0.5 + (x - camFP.cx) * fpBaseScaleX() * camFP.zoom;
  }
  function fpToPxY(y){
    return PAD + innerH()*0.5 + (y - camFP.cy) * fpBaseScaleY() * camFP.zoom;
  }
  function fpFromPxX(px){
    return camFP.cx + ((px - PAD - innerW()*0.5)/(fpBaseScaleX()*camFP.zoom));
  }
  function fpFromPxY(py){
    return camFP.cy + ((py - PAD - innerH()*0.5)/(fpBaseScaleY()*camFP.zoom));
  }

  function zoom2D(factor, pivotPx, pivotPy){
    const cam = activeCam();
    const bounds = activeBounds2D();
    if(floorplanEnabled && viewDim==='2d'){
      const minZoom = floorplanMinZoomToFit();
      const requested = camFP.zoom * factor;
      if(requested <= minZoom + 1e-6){
        camFP.zoom = minZoom;
        camFP.cx = (FLOORPLAN_BOUNDS.xMin + FLOORPLAN_BOUNDS.xMax) * 0.5;
        camFP.cy = (FLOORPLAN_BOUNDS.yMin + FLOORPLAN_BOUNDS.yMax) * 0.5;
        clampCam(camFP, FLOORPLAN_BOUNDS);
        return;
      }
    }
    const minZoom = floorplanEnabled ? floorplanMinZoomToFit() : MIN_ZOOM_2D;
    const oldZoom = cam.zoom;
    const newZoom = clamp(cam.zoom * factor, minZoom, MAX_ZOOM_2D);
    if(Math.abs(newZoom - oldZoom) < 1e-6) return;
    const worldBefore = floorplanEnabled
      ? {x: fpFromPxX(pivotPx), y: fpFromPxY(pivotPy)}
      : {x: toCmX(pivotPx), y: toCmY(pivotPy)};
    cam.zoom = newZoom;
    const worldAfter = floorplanEnabled
      ? {x: fpFromPxX(pivotPx), y: fpFromPxY(pivotPy)}
      : {x: toCmX(pivotPx), y: toCmY(pivotPy)};
    cam.cx += (worldBefore.x - worldAfter.x);
    cam.cy += (worldBefore.y - worldAfter.y);
    clampCam(cam,bounds);
  }

  function pan2D(dx,dy){
    const cam = activeCam();
    const bounds = activeBounds2D();
    const scaleX = floorplanEnabled ? fpBaseScaleX() : baseScaleX();
    const scaleY = floorplanEnabled ? fpBaseScaleY() : baseScaleY();
    cam.cx -= dx / (scaleX * cam.zoom);
    cam.cy -= dy / (scaleY * cam.zoom);
    clampCam(cam,bounds);
  }

  function drawGrid(){
    ctx.save();
    ctx.save();
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.globalCompositeOperation = 'source-over';
    ctx.globalAlpha = 1;
    ctx.fillStyle = '#0a0d12';
    ctx.fillRect(0, 0, cvs.width / dpr, cvs.height / dpr);
    ctx.restore();

    ctx.lineWidth=hairline();
    const gridColor=cssVar('--grid')||'#1e2431';
    ctx.strokeStyle=gridColor;
    ctx.globalAlpha=1;

    const x0=Math.ceil(X_MIN/GRID)*GRID, y0=Math.ceil(Y_MIN/GRID)*GRID;
    for(let x=x0;x<=X_MAX;x+=GRID){
      const px=alignPx(toPxX(x));
      ctx.beginPath();
      ctx.moveTo(px,alignPx(toPxY(Y_MIN)));
      ctx.lineTo(px,alignPx(toPxY(Y_MAX)));
      ctx.stroke();
    }
    for(let y=y0;y<=Y_MAX;y+=GRID){
      const py=alignPx(toPxY(y));
      ctx.beginPath();
      ctx.moveTo(alignPx(toPxX(X_MIN)),py);
      ctx.lineTo(alignPx(toPxX(X_MAX)),py);
      ctx.stroke();
    }
    ctx.globalAlpha=1;
    ctx.restore();
  }

  function drawCircularGrid(){
    ctx.save();
    ctx.save();
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.globalCompositeOperation = 'source-over';
    ctx.globalAlpha = 1;
    ctx.fillStyle = '#0a0d12';
    ctx.fillRect(0, 0, cvs.width / dpr, cvs.height / dpr);
    ctx.restore();

    ctx.lineWidth=hairline();
    const gridColor=cssVar('--grid')||'#1e2431';
    ctx.strokeStyle=gridColor;
    ctx.globalAlpha=1;

    const step=GRID;
    const maxR=fovMaxRange('top');
    for(let r=step;r<=maxR;r+=step){
      const pts=makeFovPoints(r,'top');
      if(pts.length<2) continue;
      ctx.beginPath();
      ctx.moveTo(toPxX(pts[0].x),toPxY(pts[0].y));
      for(let i=1;i<pts.length;i++) ctx.lineTo(toPxX(pts[i].x),toPxY(pts[i].y));
      ctx.closePath();
      ctx.stroke();
    }

    const r=maxR;
    ctx.beginPath();
    ctx.moveTo(alignPx(toPxX(-r)),alignPx(toPxY(0)));
    ctx.lineTo(alignPx(toPxX(r)),alignPx(toPxY(0)));
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(alignPx(toPxX(0)),alignPx(toPxY(-r)));
    ctx.lineTo(alignPx(toPxX(0)),alignPx(toPxY(r)));
    ctx.stroke();

    ctx.globalAlpha=1;
    ctx.restore();
  }

  function drawFloorplanGrid2D(){
    ctx.save();
    ctx.lineWidth=hairline();
    const gridColor=cssVar('--grid')||'#1e2431';
    ctx.strokeStyle=gridColor;
    ctx.globalAlpha=1;

    const b=FLOORPLAN_BOUNDS;
    const step=GRID;
    const x0=Math.ceil(b.xMin/step)*step;
    const y0=Math.ceil(b.yMin/step)*step;
    const xMax=b.xMax;
    const yMax=b.yMax;

    for(let x=x0;x<=xMax;x+=step){
      const px=alignPx(fpToPxX(x));
      ctx.beginPath();
      ctx.moveTo(px,alignPx(fpToPxY(b.yMin)));
      ctx.lineTo(px,alignPx(fpToPxY(b.yMax)));
      ctx.stroke();
    }
    for(let y=y0;y<=yMax;y+=step){
      const py=alignPx(fpToPxY(y));
      ctx.beginPath();
      ctx.moveTo(alignPx(fpToPxX(b.xMin)),py);
      ctx.lineTo(alignPx(fpToPxX(b.xMax)),py);
      ctx.stroke();
    }

    ctx.globalAlpha=1;
    ctx.restore();
  }

  const isMobileUI=()=>IS_MOBILE;
  function shouldShowFloorplanGrid(){
    if(!floorplanEnabled) return false;
    if(isMobileUI()) return false;
    if(floorplanTool==='draw' || floorplanTool==='sensor' || floorplanTool==='zone') return true;
    if(floorplanActiveLine!==null) return true;
    if(floorplanSensorDragging!==null || floorplanSensorRotating!==null) return true;
    if(floorplanZoneDragIdx!=null || floorplanZoneDragWhole) return true;
    return false;
  }

  function shouldShowFloorplanFov(){
    if(!floorplanEnabled) return false;
    return (floorplanTool==='draw' || floorplanTool==='sensor' || floorplanTool==='zone');
  }

  function drawFloorplan2DView(){
    if(shouldShowFloorplanGrid()) drawFloorplanGrid2D();
    drawFloorplanPolylines();
    drawFloorplanPreviewLine();
    drawFloorplanSensorOverlay2D();
    const sensorColor = WALL_COLOR;
    const sensorRadius = wallHandleRadius();
    floorplanSensors.forEach(s=>{
      const showHandles = floorplanTool==='sensor';
      if(!showHandles) return;
      const h = sensorHandleWorld(s);
      if(h){
        const hx=alignPx(fpToPxX(h.x)), hy=alignPx(fpToPxY(h.y));
        ctx.save();
        ctx.fillStyle=sensorColor;
        ctx.strokeStyle=WALL_HANDLE_SHADOW;
        ctx.lineWidth=hairline();
        ctx.beginPath();
        ctx.arc(hx,hy,sensorRadius,0,Math.PI*2);
        ctx.fill();
        ctx.stroke();
        ctx.restore();
      }
      ctx.save();
      const x=alignPx(fpToPxX(s.x)), y=alignPx(fpToPxY(s.y));
      ctx.fillStyle=sensorColor;
      ctx.strokeStyle=WALL_HANDLE_SHADOW;
      ctx.lineWidth=hairline();
      ctx.beginPath();
      ctx.arc(x,y,sensorRadius,0,Math.PI*2);
      ctx.fill();
      ctx.stroke();
      ctx.restore();
    });
    if(floorplanTool==='sensor' && floorplanSensorHover){
      ctx.save();
      const x=alignPx(fpToPxX(floorplanSensorHover.x)), y=alignPx(fpToPxY(floorplanSensorHover.y));
      ctx.fillStyle=sensorColor;
      ctx.strokeStyle=WALL_HANDLE_SHADOW;
      ctx.lineWidth=hairline();
      ctx.beginPath();
      ctx.arc(x,y,sensorRadius,0,Math.PI*2);
      ctx.fill();
      ctx.stroke();
      ctx.restore();
    }
    drawFloorplanHandles();
  }

  function makeFovPoints(range, mode='side'){
    const pts=[];
    const rad=Math.PI/180;
    const limit=fovMaxRange(mode);
    const r=Math.max(0,Math.min(limit,range|0));
    if(mode==='top'){
      for(let a=0;a<=360;a+=3){
        const x=r*Math.sin(a*rad);
        const y=r*Math.cos(a*rad);
        pts.push({x,y});
      }
      if(pts.length) pts.push({x:pts[0].x,y:pts[0].y});
      return pts;
    }
    const half=FOV_DEG/2;
    pts.push({x:0,y:0});
    for(let a=-half;a<=half;a+=1){
      const x=r*Math.sin(a*rad);
      const y=r*Math.cos(a*rad);
      pts.push({x,y});
    }
    pts.push({x:0,y:0});
    return pts;
  }

  function makeFovArcPoints(range, mode='side'){
    const pts=[];
    const rad=Math.PI/180;
    const limit=fovMaxRange(mode);
    const r=Math.max(0,Math.min(limit,range|0));
    if(mode==='top'){
      for(let a=0;a<=360;a+=3){
        pts.push({x:r*Math.sin(a*rad), y:r*Math.cos(a*rad)});
      }
    }else{
      const half=FOV_DEG/2;
      for(let a=-half;a<=half;a+=2){
        pts.push({x:r*Math.sin(a*rad), y:r*Math.cos(a*rad)});
      }
    }
    return pts;
  }

  function drawFov(range,lighter=false){
    const maxR=fovMaxRange();
    const r=Math.max(0,Math.min(maxR,range|0));
    const pts=makeFovPoints(r, installMode);
    ctx.beginPath();
    ctx.moveTo(toPxX(pts[0].x),toPxY(pts[0].y));
    for(let i=1;i<pts.length;i++) ctx.lineTo(toPxX(pts[i].x),toPxY(pts[i].y));
    ctx.closePath();
    ctx.globalAlpha=lighter?0.10:0.18;
    ctx.fillStyle=cssVar('--fov');
    ctx.fill();
    ctx.globalAlpha=1;
  }

  function drawFovGuides2D(){
    const maxR=fovMaxRange();
    if(maxR<=0) return;
    ctx.save();
    ctx.lineWidth=Math.max(1, hairline()*1);
    ctx.strokeStyle=cssVar('--fov')||'#1e2431';
    ctx.globalAlpha=0.25;

    for(let r=GRID;r<=maxR;r+=GRID){
      const pts=makeFovArcPoints(r, installMode);
      if(pts.length<2) continue;
      ctx.beginPath();
      ctx.moveTo(toPxX(pts[0].x),toPxY(pts[0].y));
      for(let i=1;i<pts.length;i++) ctx.lineTo(toPxX(pts[i].x),toPxY(pts[i].y));
      if(installMode==='top') ctx.closePath();
      ctx.stroke();
    }

    if(installMode==='top'){
      ctx.beginPath();
      ctx.moveTo(alignPx(toPxX(-maxR)),alignPx(toPxY(0)));
      ctx.lineTo(alignPx(toPxX(maxR)),alignPx(toPxY(0)));
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(alignPx(toPxX(0)),alignPx(toPxY(-maxR)));
      ctx.lineTo(alignPx(toPxX(0)),alignPx(toPxY(maxR)));
      ctx.stroke();
    }else{
      const ox=alignPx(toPxX(0)), oy=alignPx(toPxY(0));
      const half=FOV_DEG/2;
      for(const a of [-half, 0, half]){
        const ang=a * Math.PI/180;
        const x=Math.sin(ang)*maxR;
        const y=Math.cos(ang)*maxR;
        ctx.beginPath();
        ctx.moveTo(ox,oy);
        ctx.lineTo(alignPx(toPxX(x)),alignPx(toPxY(y)));
        ctx.stroke();
      }
    }

    ctx.globalAlpha=1;
    ctx.restore();
  }

  function drawPolygon(pts,style){
    if(!pts || pts.length<2) return;
    ctx.beginPath();
    ctx.moveTo(toPxX(pts[0].x),toPxY(pts[0].y));
    for(let i=1;i<pts.length;i++) ctx.lineTo(toPxX(pts[i].x),toPxY(pts[i].y));
    if(pts.length>=3) ctx.closePath();
    if(style.fill){
      ctx.globalAlpha=style.fillAlpha??1;
      ctx.fillStyle=style.fill;
      ctx.fill();
    }
    if(style.stroke){
      ctx.globalAlpha=1;
      ctx.lineWidth=style.width??2;
      ctx.strokeStyle=style.stroke;
      ctx.stroke();
    }
    ctx.globalAlpha=1;
  }

  function drawFloorplanPolylines(){
    if(!floorplanPolylines.length) return;
    const style=wallStyle();
    ctx.save();
    ctx.strokeStyle=style.stroke;
    ctx.lineWidth=style.width;
    ctx.lineCap='round';
    ctx.lineJoin='round';
    ctx.globalAlpha=0.9;
    for(const line of floorplanPolylines){
      if(!line || line.length<2) continue;
      ctx.beginPath();
      ctx.moveTo(alignPx(fpToPxX(line[0].x)), alignPx(fpToPxY(line[0].y)));
      for(let i=1;i<line.length;i++){
        ctx.lineTo(alignPx(fpToPxX(line[i].x)), alignPx(fpToPxY(line[i].y)));
      }
      ctx.stroke();
    }
    ctx.globalAlpha=1;
    ctx.restore();
  }

  function drawFloorplanHandles(){
    if(!floorplanEditEnabled) return;
    const style = wallStyle();
    ctx.save();
    for(const line of floorplanPolylines){
      if(!line) continue;
      for(const p of line){
        const x=alignPx(fpToPxX(p.x)), y=alignPx(fpToPxY(p.y));
        ctx.beginPath();
        ctx.arc(x,y,wallHandleRadius(),0,Math.PI*2);
        ctx.fillStyle = style.stroke;
        ctx.strokeStyle = WALL_HANDLE_SHADOW;
        ctx.lineWidth = hairline();
        ctx.fill();
        ctx.stroke();
      }
    }
    if(floorplanPreview){
      ctx.beginPath();
      ctx.arc(alignPx(fpToPxX(floorplanPreview.x)), alignPx(fpToPxY(floorplanPreview.y)), wallHandleRadius(), 0, Math.PI*2);
      ctx.fillStyle = style.stroke;
      ctx.strokeStyle = WALL_HANDLE_SHADOW;
      ctx.fill();
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawFloorplanPreviewLine(){
    if(!floorplanEditEnabled) return;
    if(floorplanActiveLine===null) return;
    const line=floorplanPolylines[floorplanActiveLine];
    if(!line || !line.length || !floorplanPreview) return;
    const last=line[line.length-1];
    const dist=Math.hypot(floorplanPreview.x-last.x,floorplanPreview.y-last.y);
    const labelVal = floorplanLengthInput ? Number(floorplanLengthInput) : dist;
    const label=`${Math.round(labelVal)} cm`;
    const style=wallStyle();
    ctx.save();
    ctx.strokeStyle=style.stroke;
    ctx.lineWidth=style.width;
    ctx.lineCap='round';
    ctx.lineJoin='round';
    ctx.globalAlpha=0.9;
    const sx=alignPx(fpToPxX(last.x)), sy=alignPx(fpToPxY(last.y));
    const ex=alignPx(fpToPxX(floorplanPreview.x)), ey=alignPx(fpToPxY(floorplanPreview.y));
    const dx=ex-sx, dy=ey-sy;
    const lenPx=Math.hypot(dx,dy)||1;
    const ux=dx/lenPx, uy=dy/lenPx;
    const isHoriz=Math.abs(dx)>=Math.abs(dy);

    const ui=uiScale();
    ctx.font=`bold ${12*ui}px system-ui`;
    const metrics=ctx.measureText(label);
    const pad=6*ui;
    const textW=metrics.width+pad*2;
    const textH=12*ui+pad*2;
    const gapAlong=isHoriz ? textW : textW;
    const gapHalf=gapAlong*0.5 + 4;
    const midx=sx+dx*0.5, midy=sy+dy*0.5;

    if(lenPx > gapAlong+8){
      const cutSx=midx-ux*gapHalf, cutSy=midy-uy*gapHalf;
      const cutEx=midx+ux*gapHalf, cutEy=midy+uy*gapHalf;
      ctx.beginPath();
      ctx.moveTo(sx,sy);
      ctx.lineTo(cutSx,cutSy);
      ctx.moveTo(cutEx,cutEy);
      ctx.lineTo(ex,ey);
      ctx.stroke();
    }else{
      ctx.beginPath();
      ctx.moveTo(sx,sy);
      ctx.lineTo(ex,ey);
      ctx.stroke();
    }

    if(dist>0.05){
      ctx.save();
      ctx.translate(midx,midy);
      if(!isHoriz){
        ctx.rotate(-Math.PI/2);
      }
      ctx.textBaseline='middle';
      ctx.textAlign='center';
      ctx.fillStyle='#e6eaf1';
      ctx.strokeStyle='rgba(0,0,0,0.55)';
      ctx.lineWidth=3;
      ctx.strokeText(label,0,0);
      ctx.fillText(label,0,0);
      ctx.restore();
    }
    ctx.restore();
  }

  function zoneStyle(key,active){
    const width = wallStrokeWidth();
    const isExcl = key==='excl';
    const strokeVar = isExcl
      ? (active ? '--z-excl' : '--z-excl-dim')
      : (active ? '--z-norm' : '--z-norm-dim');
    const fillVar = isExcl
      ? (active ? '--z-excl-fill' : '--z-excl-dim-fill')
      : (active ? '--z-norm-fill' : '--z-norm-dim-fill');
    return {
      fill: cssVar(fillVar) || (isExcl ? cssVar('--z-excl-fill') : cssVar('--z-norm-fill')),
      stroke: cssVar(strokeVar) || (isExcl ? cssVar('--z-excl') : cssVar('--z-norm')),
      width,
      fillAlpha:1
    };
  }

  const mobileTargetScale=()=> (isMobileUI() ? 0.8 : 1);
  function targetRadius(){
    return wallHandleRadius() * mobileTargetScale();
  }

  function floorplanTargetRadius(){
    return wallHandleRadius() * mobileTargetScale();
  }

  const T_JOIN_EPS = 0.75;
  function pointOnSegmentInterior(pt,a,b,eps=T_JOIN_EPS){
    const vx=b.x-a.x, vy=b.y-a.y;
    const len2=vx*vx+vy*vy;
    if(len2<1e-6) return false;
    const proj=((pt.x-a.x)*vx+(pt.y-a.y)*vy)/len2;
    if(proj<=eps/Math.sqrt(len2) || proj>=1-eps/Math.sqrt(len2)) return false;
    const px=a.x+proj*vx, py=a.y+proj*vy;
    const dist=Math.hypot(pt.x-px, pt.y-py);
    return dist<=eps;
  }

  function floorplanNodeDegrees(){
    const deg=new Map();
    const key=(p)=>`${p.x.toFixed(2)},${p.y.toFixed(2)}`;
    for(const line of floorplanPolylines){
      if(!line || line.length<2) continue;
      for(let i=0;i<line.length-1;i++){
        const p0=line[i], p1=line[i+1];
        const k0=key(p0), k1=key(p1);
        deg.set(k0,(deg.get(k0)||0)+1);
        deg.set(k1,(deg.get(k1)||0)+1);
      }
    }
    return deg;
  }

  function drawHandles(pts){
    if(!pts || !pts.length) return;
    const isExcl=currentZone==='excl';
    const color=isExcl?(cssVar('--z-excl')||WALL_COLOR):(cssVar('--z-norm')||WALL_COLOR);
    const radius=wallHandleRadius();
    ctx.save();
    for(let i=0;i<pts.length;i++){
      const px=alignPx(toPxX(pts[i].x)), py=alignPx(toPxY(pts[i].y));
      ctx.beginPath();
      ctx.arc(px,py,radius,0,Math.PI*2);
      ctx.fillStyle=color;
      ctx.strokeStyle=WALL_HANDLE_SHADOW;
      ctx.lineWidth=hairline();
      ctx.fill();
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawTargets(){
    if(viewDim !== '2d') return;
    const live = livePosFor(selectedDevice?.device_id);

    const color = WALL_COLOR;
    const r = targetRadius();
    for (const n of [1, 2, 3, 4, 5]) {
      const p = live[n];
      if (!p || !Number.isFinite(p.x) || !Number.isFinite(p.y) || (p.x === 0 && p.y === 0)) continue;
      const px = toPxX(clampBaseX(p.x));
      const py = toPxY(clampBaseY(p.y));
      ctx.beginPath();
      ctx.arc(px, py, r, 0, Math.PI * 2);
      ctx.fillStyle = color;
      ctx.fill();
    }
  }

  async function fetchHistoricalData(entityIds,hours=24){
    if(!selectedDevice) return [];
    const body=(entityIds&&entityIds.length)
      ? {entity_ids:entityIds,hours}
      : {device_id:selectedDevice.device_id,hours};
    const res=await api('api/historical_targets',body);
    const positions=res.positions||[];
    return positions;
  }

  function buildPalette(){
    const stops=[
      [0,[13,32,56]],
      [0.12,[42,123,255]],
      [0.35,[65,255,212]],
      [0.6,[166,255,99]],
      [0.8,[255,224,102]],
      [0.92,[255,154,92]],
      [1,[255,107,107]]
    ];
    const lut=new Uint8ClampedArray(256*4);
    for(let i=0;i<256;i++){
      const t=i/255;
      let a=stops[0], b=stops[stops.length-1];
      for(let s=1;s<stops.length;s++){
        if(t<=stops[s][0]){
          a=stops[s-1];
          b=stops[s];
          break;
        }
      }
      const span=(b[0]-a[0])||1;
      const k=(t-a[0])/span;
      const r=Math.round(a[1][0]+(b[1][0]-a[1][0])*k);
      const g=Math.round(a[1][1]+(b[1][1]-a[1][1])*k);
      const bl=Math.round(a[1][2]+(b[1][2]-a[1][2])*k);
      const off=i*4;
      lut[off]=r;
      lut[off+1]=g;
      lut[off+2]=bl;
      lut[off+3]=255;
    }
    return lut;
  }
  const PALETTE=buildPalette();

  function gaussianKernel1D(sigma){
    const radius = Math.max(1, Math.ceil(sigma * 3));
    const size = radius*2 + 1;
    const k = new Float32Array(size);
    const s2 = 2*sigma*sigma;
    let sum = 0;
    for(let i=-radius, idx=0; i<=radius; i++, idx++){
      const v = Math.exp(-(i*i)/s2);
      k[idx]=v;
      sum+=v;
    }
    for(let i=0;i<size;i++) k[i]/=sum;
    return {k, radius, size};
  }

  function kdeHeatmap(points, w, h){
    const grid = new Float32Array(w*h);
    const pw = Math.max(0.01, TUNE.pointWeight);
    const b = baseBounds();
    const worldW = b.xMax - b.xMin;
    const worldH = b.yMax - b.yMin;
    for(const p of points){
      const x = (p.x - b.xMin) / worldW * (w-1);
      const y = (p.y - b.yMin) / worldH * (h-1);
      if(!Number.isFinite(x) || !Number.isFinite(y)) continue;
      if(x<0||x>w-1||y<0||y>h-1) continue;
      const x0 = Math.floor(x), y0 = Math.floor(y);
      const dx = x - x0, dy = y - y0;
      const x1 = Math.min(w-1, x0+1), y1 = Math.min(h-1, y0+1);
      const w00 = (1-dx)*(1-dy)*pw, w10 = dx*(1-dy)*pw, w01 = (1-dx)*dy*pw, w11 = dx*dy*pw;
      grid[y0*w + x0] += w00;
      grid[y0*w + x1] += w10;
      grid[y1*w + x0] += w01;
      grid[y1*w + x1] += w11;
    }
    return grid;
  }

  function normalizeDensity(values){
    let maxV = 0;
    const samples = [];
    for(let i=0;i<values.length;i++){
      const v = values[i];
      if(v>0){
        samples.push(v);
        if(v>maxV) maxV=v;
      }
    }
    let norm = maxV || 1;
    if(samples.length){
      samples.sort((a,b)=>a-b);
      const p = Math.max(0.5, Math.min(0.999, TUNE.clipPercentile));
      norm = samples[Math.floor(samples.length * p)] || norm;
    }
    const gamma = Math.max(0.2, TUNE.gamma);
    const cutoff = Math.max(0, Math.min(0.95, TUNE.minCutoff));
    const out = new Float32Array(values.length);

    for(let i=0;i<values.length;i++){
      const v = values[i];
      if(v<=0){ out[i]=0; continue; }
      let t = Math.min(1, v / norm);
      if(t < cutoff){ out[i]=0; continue; }
      t = (t - cutoff) / (1 - cutoff);
      t = Math.pow(t, gamma);
      out[i]=t;
    }
    return out;
  }

  function normalizeHeight(values){
    let maxV = 0;
    for(let i=0;i<values.length;i++){
      if(values[i] > maxV) maxV = values[i];
    }
    const norm = maxV || 1;
    const out = new Float32Array(values.length);
    const gamma = 0.85;
    for(let i=0;i<values.length;i++){
      const v = values[i];
      if(v<=0){ out[i]=0; continue; }
      let t = v / norm;
      if(t < 0) t = 0;
      if(t > 1) t = 1;
      out[i] = Math.pow(t, gamma);
    }
    return out;
  }

  function ensureHeatmapField(){
    const w = Math.max(2, Math.round(innerW()));
    const h = Math.max(2, Math.round(innerH()));
    if(!heatmapPositions.length){
      heatmapFieldColor=null;
      heatmapFieldHeight=null;
      return null;
    }
    if(heatmapFieldColor && heatmapFieldHeight && heatmapFieldW===w && heatmapFieldH===h){
      return {color:heatmapFieldColor, height:heatmapFieldHeight, w, h};
    }

    const base = kdeHeatmap(heatmapPositions, w, h);
    const N = Math.max(1, heatmapPositions.length);
    const meanSpacing = Math.sqrt((w*h)/N);
    const sigma0 = Math.max(1.5, Math.min(Math.min(w,h)*0.08, meanSpacing*0.9));
    const sigma = sigma0 * TUNE.sigmaScale;
    const {k, radius} = gaussianKernel1D(sigma);

    const tmp = new Float32Array(w*h);
    for(let y=0; y<h; y++){
      const off = y*w;
      for(let x=0; x<w; x++){
        let acc=0;
        for(let i=-radius, idx=0; i<=radius; i++, idx++){
          const xx = Math.max(0, Math.min(w-1, x+i));
          acc += base[off + xx] * k[idx];
        }
        tmp[off + x] = acc;
      }
    }

    const blurred = new Float32Array(w*h);
    for(let x=0; x<w; x++){
      for(let y=0; y<h; y++){
        let acc=0;
        for(let i=-radius, idx=0; i<=radius; i++, idx++){
          const yy = Math.max(0, Math.min(h-1, y+i));
          acc += tmp[yy*w + x] * k[idx];
        }
        blurred[y*w + x] = acc;
      }
    }

    const density = normalizeDensity(blurred);

    const masked = new Float32Array(blurred.length);
    for(let i=0;i<blurred.length;i++){
      masked[i] = blurred[i] * density[i];
    }

    heatmapFieldColor  = density;
    heatmapFieldHeight = normalizeHeight(masked);
    heatmapFieldW = w;
    heatmapFieldH = h;
    return {color:heatmapFieldColor, height:heatmapFieldHeight, w, h};
  }

  function colorizeAndDrawField(fieldColor, w, h){
    const img = ctx.createImageData(w,h);
    const d   = img.data;
    const aMax = Math.max(0, Math.min(255, TUNE.maxAlpha));

    for(let i=0;i<fieldColor.length;i++){
      const t = fieldColor[i];
      if(t<=0){ d[i*4+3]=0; continue; }
      const idx = Math.min(255, (t*255)|0);
      const o   = idx*4;
      d[i*4]   = PALETTE[o];
      d[i*4+1] = PALETTE[o+1];
      d[i*4+2] = PALETTE[o+2];
      d[i*4+3] = Math.round(35 + (aMax-35)*t);
    }

    const offscreen = document.createElement('canvas');
    offscreen.width  = w;
    offscreen.height = h;
    const octx = offscreen.getContext('2d');
    octx.imageSmoothingEnabled=false;
    octx.putImageData(img,0,0);

    const scaleX = baseScaleX() * cam2D.zoom;
    const scaleY = baseScaleY() * cam2D.zoom;
    const b = baseBounds();
    const worldW = b.xMax - b.xMin;
    const worldH = b.yMax - b.yMin;
    const drawX = PAD + innerW()*0.5 + (b.xMin - cam2D.cx) * scaleX;
    const drawY = PAD + innerH()*0.5 + (b.yMin - cam2D.cy) * scaleY;
    const drawW = worldW * scaleX;
    const drawH = worldH * scaleY;

    ctx.save();
    const maxR = fovMaxRange();
    const rDet = detRange>0 ? Math.min(detRange, maxR) : maxR;
    const pts = makeFovPoints(rDet, installMode);
    ctx.beginPath();
    ctx.moveTo(toPxX(pts[0].x), toPxY(pts[0].y));
    for(let i=1;i<pts.length;i++){
      ctx.lineTo(toPxX(pts[i].x), toPxY(pts[i].y));
    }
    ctx.closePath();
    ctx.clip();

    ctx.drawImage(offscreen, drawX, drawY, drawW, drawH);
    ctx.restore();
  }

  function drawHeatmap2D(){
    if(viewMode!=='heatmap' || !heatmapPositions.length) return;
    const cached = ensureHeatmapField();
    if(!cached) return;
    colorizeAndDrawField(cached.color, cached.w, cached.h);
  }

  function updateCamera3D(bounds=activeBounds()){
    const iw = innerW();
    const ih = innerH();
    cam3D.aspect = iw / ih;

    clampOrbitTarget(bounds);

    cam3D.target.x = ORBIT_TARGET.x;
    cam3D.target.y = 0;
    cam3D.target.z = ORBIT_TARGET.z;

    ORBIT.distance  = clamp(ORBIT.distance,  ORBIT_LIMITS.minDist, ORBIT_LIMITS.maxDist);
    ORBIT.elevation = clamp(ORBIT.elevation, ORBIT_LIMITS.minElev, ORBIT_LIMITS.maxElev);

    cam3D.cosA = Math.cos(ORBIT.azimuth);
    cam3D.sinA = Math.sin(ORBIT.azimuth);
    cam3D.cosE = Math.cos(ORBIT.elevation);
    cam3D.sinE = Math.sin(ORBIT.elevation);

    cam3D.pos.x = cam3D.target.x + ORBIT.distance * cam3D.cosE * cam3D.sinA;
    cam3D.pos.y = cam3D.target.y + ORBIT.distance * cam3D.sinE;
    cam3D.pos.z = cam3D.target.z + ORBIT.distance * cam3D.cosE * cam3D.cosA;

    const fovRad = cam3D.fovDeg * Math.PI / 180;
    cam3D.scale = (ih * 0.5) / Math.tan(fovRad / 2);

    cam3D.cx = PAD + iw * 0.5;
    cam3D.cy = PAD + ih * 0.5;
  }

  function worldToCamera(wx,wy,wz){
    const dx = wx - cam3D.pos.x;
    const dy = wy - cam3D.pos.y;
    const dz = wz - cam3D.pos.z;

    const x1 =  cam3D.cosA * dx - cam3D.sinA * dz;
    const z1 =  cam3D.sinA * dx + cam3D.cosA * dz;

    const y1 =  cam3D.cosE * dy - cam3D.sinE * z1;
    const z2 =  cam3D.sinE * dy + cam3D.cosE * z1;

    const z = -z2;
    return {x:x1, y:y1, z};
  }

  function project3D(wx,wy,wz){
    const p = worldToCamera(wx,wy,wz);
    if(p.z <= cam3D.near) return null;
    const sx = cam3D.cx + (p.x * cam3D.scale)/p.z;
    const sy = cam3D.cy - (p.y * cam3D.scale)/p.z;
    return {x:sx, y:sy, z:p.z};
  }

  function panOrbit(dx, dy){
    updateCamera3D();
    const speed = ORBIT.distance * ORBIT_PAN_SPEED;
    const rightX = cam3D.cosA;
    const rightZ = -cam3D.sinA;
    const fwdX = cam3D.sinA;
    const fwdZ = cam3D.cosA;

    ORBIT_TARGET.x -= (dx * rightX + dy * fwdX) * speed;
    ORBIT_TARGET.z -= (dx * rightZ + dy * fwdZ) * speed;
    clampOrbitTarget(activeBounds());
  }

  function clipProjectSegment(wx0,wy0,wz0, wx1,wy1,wz1){
    const c0 = worldToCamera(wx0,wy0,wz0);
    const c1 = worldToCamera(wx1,wy1,wz1);
    const near = cam3D.near;

    const behind0 = c0.z <= near;
    const behind1 = c1.z <= near;
    if(behind0 && behind1) return null;

    let p0 = c0, p1 = c1;
    if(behind0 || behind1){
      const dz = c1.z - c0.z;
      if(Math.abs(dz) < 1e-6) return null;
      const t = (near + 1e-4 - c0.z) / dz;
      const clipPoint = {
        x: c0.x + (c1.x - c0.x) * t,
        y: c0.y + (c1.y - c0.y) * t,
        z: near + 1e-4
      };
      if(behind0) p0 = clipPoint;
      else p1 = clipPoint;
    }

    const s0 = {
      x: cam3D.cx + (p0.x * cam3D.scale)/p0.z,
      y: cam3D.cy - (p0.y * cam3D.scale)/p0.z,
      z: p0.z
    };
    const s1 = {
      x: cam3D.cx + (p1.x * cam3D.scale)/p1.z,
      y: cam3D.cy - (p1.y * cam3D.scale)/p1.z,
      z: p1.z
    };
    return {a:s0,b:s1};
  }

  function drawGrid3D(bounds=BASE_BOUNDS, step=GRID){
    const gridColor=cssVar('--grid')||'#1e2431';
    ctx.save();
    ctx.lineWidth=hairline();
    ctx.strokeStyle=gridColor;
    ctx.globalAlpha=1;

    const zStart = bounds.yMin;
    const zEnd   = bounds.yMax;
    const xStart = bounds.xMin;
    const xEnd   = bounds.xMax;

    for(let x=Math.ceil(xStart/step)*step;x<=xEnd;x+=step){
      const seg = clipProjectSegment(x,0,zStart, x,0,zEnd);
      if(!seg) continue;
      ctx.beginPath();
      ctx.moveTo(alignPx(seg.a.x),alignPx(seg.a.y));
      ctx.lineTo(alignPx(seg.b.x),alignPx(seg.b.y));
      ctx.stroke();
    }
    for(let z=Math.ceil(zStart/step)*step; z<=zEnd; z+=step){
      const seg = clipProjectSegment(xStart,0,z, xEnd,0,z);
      if(!seg) continue;
      ctx.beginPath();
      ctx.moveTo(alignPx(seg.a.x),alignPx(seg.a.y));
      ctx.lineTo(alignPx(seg.b.x),alignPx(seg.b.y));
      ctx.stroke();
    }

    ctx.globalAlpha=1;
    ctx.restore();
  }

  function drawFov3D(range,lighter=false){
    const maxR = fovMaxRange();
    const r = Math.max(0, Math.min(maxR, range|0));
    if(!r) return;

    const rad  = Math.PI/180;

    const pts=[];
    if(installMode==='top'){
      for(let a=0; a<=360; a+=3){
        pts.push({
          x: r*Math.sin(a*rad),
          y: 0,
          z: r*Math.cos(a*rad)
        });
      }
    }else{
      const half = FOV_DEG/2;
      pts.push({x:0,y:0,z:0});
      for(let a=-half; a<=half; a+=3){
        pts.push({
          x: r*Math.sin(a*rad),
          y: 0,
          z: r*Math.cos(a*rad)
        });
      }
      pts.push({x:0,y:0,z:0});
    }

    ctx.save();

    ctx.beginPath();
    let first=true;
    for(const w of pts){
      const p=project3D(w.x,w.y,w.z);
      if(!p) continue;
      if(first){ ctx.moveTo(p.x,p.y); first=false; }
      else ctx.lineTo(p.x,p.y);
    }
    if(!first){
      ctx.closePath();
      ctx.globalAlpha=lighter?0.10:0.18;
      ctx.fillStyle=cssVar('--fov');
      ctx.fill();
    }

    ctx.globalAlpha=1;
    ctx.restore();
  }

  function drawFovGuides3D(){
    const maxR=fovMaxRange();
    if(maxR<=0) return;
    ctx.save();
    ctx.lineWidth=Math.max(1, hairline()*1);
    ctx.strokeStyle=cssVar('--fov')||'#1e2431';
    ctx.globalAlpha=0.25;

    function strokeArc(range){
      const pts=makeFovArcPoints(range, installMode);
      if(pts.length<2) return;
      ctx.beginPath();
      let first=true;
      for(const p of pts){
        const proj=project3D(p.x,0,p.y);
        if(!proj) continue;
        if(first){ ctx.moveTo(proj.x,proj.y); first=false; }
        else ctx.lineTo(proj.x,proj.y);
      }
      if(!first && installMode==='top') ctx.closePath();
      if(!first) ctx.stroke();
    }

    for(let r=GRID;r<=maxR;r+=GRID){
      strokeArc(r);
    }

    function strokeLine3D(a,b){
      const pa=project3D(a.x,a.y,a.z);
      const pb=project3D(b.x,b.y,b.z);
      if(!pa || !pb) return;
      ctx.beginPath();
      ctx.moveTo(pa.x,pa.y);
      ctx.lineTo(pb.x,pb.y);
      ctx.stroke();
    }

    if(installMode==='top'){
      strokeLine3D({x:-maxR,y:0,z:0},{x:maxR,y:0,z:0});
      strokeLine3D({x:0,y:0,z:-maxR},{x:0,y:0,z:maxR});
    }else{
      const half=FOV_DEG/2;
      for(const a of [-half, 0, half]){
        const ang=a * Math.PI/180;
        const x=Math.sin(ang)*maxR;
        const z=Math.cos(ang)*maxR;
        strokeLine3D({x:0,y:0,z:0},{x,y:0,z});
      }
    }

    ctx.globalAlpha=1;
    ctx.restore();
  }

  function offsetPoints(base, origin){
    if(!origin) return [];
    return (base||[]).map(p=>({x:(p.x||0)+origin.x, y:(p.y||0)+origin.y}));
  }

  function rotatePoints(pts, angle){
    if(!pts || !pts.length) return [];
    const cosA=Math.cos(angle), sinA=Math.sin(angle);
    return pts.map(p=>({
      x:p.x*cosA - p.y*sinA,
      y:p.x*sinA + p.y*cosA
    }));
  }

  function sensorAtPx(px,py){
    let bestIdx=-1, bestDist=Infinity;
    floorplanSensors.forEach((s,i)=>{
      const dx=fpToPxX(s.x)-px;
      const dy=fpToPxY(s.y)-py;
      const dist=Math.hypot(dx,dy);
      if(dist<=FLOORPLAN_SENSOR_SNAP_PX && dist<bestDist){
        bestIdx=i; bestDist=dist;
      }
    });
    return bestIdx;
  }

  function sensorHandleWorld(sensor){
    if(!sensor) return null;
    const mode=sensorInstallMode(sensor);
    const ang = sensorAngle(sensor);
    const r = sensorFovRange(sensor, mode);
    return {
      x: sensor.x - Math.sin(ang)*r,
      y: sensor.y + Math.cos(ang)*r,
      r
    };
  }

  function sensorLocalToWorld(pt, sensor){
    if(!sensor || !pt) return {x:0,y:0};
    const ang = sensorAngle(sensor);
    const cosA=Math.cos(ang), sinA=Math.sin(ang);
    return {
      x: sensor.x + pt.x*cosA - pt.y*sinA,
      y: sensor.y + pt.x*sinA + pt.y*cosA
    };
  }

  function sensorWorldToLocal(world, sensor){
    if(!sensor || !world) return {x:0,y:0};
    const ang = sensorAngle(sensor);
    const cosA=Math.cos(ang), sinA=Math.sin(ang);
    const dx = world.x - sensor.x;
    const dy = world.y - sensor.y;
    return {
      x: dx*cosA + dy*sinA,
      y: -dx*sinA + dy*cosA
    };
  }

  function syncActiveFloorplanSensorZones(){
    const s = activeFloorplanSensor();
    if(!s) return;
    const idx = s.device_id
      ? floorplanSensors.findIndex(x=>x.device_id===s.device_id)
      : floorplanSensors.indexOf(s);
    if(idx<0) return;
    const updated = clampSensorPos({
      ...floorplanSensors[idx],
      zones: cloneZones(zones),
      detRange: detRange
    });
    floorplanSensors[idx]=updated;
  }


  function sensorRotateHit(px,py){
    let hitIdx=-1, angle=0;
    floorplanSensors.forEach((s,i)=>{
      const h=sensorHandleWorld(s);
      if(!h) return;
      const hx=fpToPxX(h.x), hy=fpToPxY(h.y);
      const dist=Math.hypot(hx-px, hy-py);
      if(dist<=FLOORPLAN_SENSOR_SNAP_PX){
        hitIdx=i;
        const dx = h.x - s.x;
        const dy = h.y - s.y;
        angle=Math.atan2(-dx, dy);
      }
    });
    return {hitIdx,angle};
  }

  function activeFloorplanSensor(){
    const devId = selectedDevice?.device_id;
    if(devId){
      const match = floorplanSensors.find(s=>s.device_id===devId);
      if(match) return match;
    }
    return floorplanSensors[0] || null;
  }

  function floorplanSensorsForOverlay(){
    return floorplanSensors;
  }


  function syncActiveSensorState(){
    const devId=selectedDevice?.device_id;
    if(!devId) return;
    const idx=floorplanSensors.findIndex(s=>s.device_id===devId);
    if(idx>=0){
      floorplanSensors[idx]=clampSensorPos({
        ...floorplanSensors[idx],
        detRange,
        zones: cloneZones(zones)
      });
    }
  }

  function drawFloorplanPoly2D(pts, style){
    if(!pts || pts.length<2) return;
    ctx.beginPath();
    ctx.moveTo(fpToPxX(pts[0].x), fpToPxY(pts[0].y));
    for(let i=1;i<pts.length;i++){
      ctx.lineTo(fpToPxX(pts[i].x), fpToPxY(pts[i].y));
    }
    if(pts.length>=3) ctx.closePath();
    if(style.fill){
      ctx.globalAlpha=style.fillAlpha??1;
      ctx.fillStyle=style.fill;
      ctx.fill();
    }
    if(style.stroke){
      ctx.globalAlpha=1;
      ctx.lineWidth=style.width??2;
      ctx.strokeStyle=style.stroke;
      ctx.stroke();
    }
    ctx.globalAlpha=1;
  }

  function drawFloorplanFov2DAt(range, origin, sensor=null, mode='side'){
    const r=clampFovRange(range, mode);
    if(!r || !origin) return;
    const ang=sensorAngle(sensor);
    const pts=offsetPoints(rotatePoints(makeFovPoints(r, mode), ang), origin);
    if(!pts.length) return;
    ctx.beginPath();
    ctx.moveTo(fpToPxX(pts[0].x), fpToPxY(pts[0].y));
    for(let i=1;i<pts.length;i++) ctx.lineTo(fpToPxX(pts[i].x), fpToPxY(pts[i].y));
    ctx.closePath();
    ctx.globalAlpha=0.18;
    ctx.fillStyle=cssVar('--fov');
    ctx.fill();
    ctx.globalAlpha=1;
  }

  function drawFloorplanFovGuides2DAt(range, origin, sensor=null, mode='side'){
    const rMax=clampFovRange(range, mode);
    if(rMax<=0 || !origin) return;
    const ang=sensorAngle(sensor);
    ctx.save();
    ctx.lineWidth=Math.max(1, hairline()*1);
    ctx.strokeStyle=cssVar('--fov')||'#1e2431';
    ctx.globalAlpha=0.25;

    for(let r=GRID;r<=rMax;r+=GRID){
      const pts=offsetPoints(rotatePoints(makeFovArcPoints(r, mode), ang), origin);
      if(pts.length<2) continue;
      ctx.beginPath();
      ctx.moveTo(fpToPxX(pts[0].x), fpToPxY(pts[0].y));
      for(let i=1;i<pts.length;i++) ctx.lineTo(fpToPxX(pts[i].x), fpToPxY(pts[i].y));
      if(mode==='top') ctx.closePath();
      ctx.stroke();
    }

    if(mode==='top'){
      const hLine=offsetPoints(rotatePoints([{x:-rMax,y:0},{x:rMax,y:0}], ang), origin);
      ctx.beginPath();
      ctx.moveTo(alignPx(fpToPxX(hLine[0].x)), alignPx(fpToPxY(hLine[0].y)));
      ctx.lineTo(alignPx(fpToPxX(hLine[1].x)), alignPx(fpToPxY(hLine[1].y)));
      ctx.stroke();

      const vLine=offsetPoints(rotatePoints([{x:0,y:-rMax},{x:0,y:rMax}], ang), origin);
      ctx.beginPath();
      ctx.moveTo(alignPx(fpToPxX(vLine[0].x)), alignPx(fpToPxY(vLine[0].y)));
      ctx.lineTo(alignPx(fpToPxX(vLine[1].x)), alignPx(fpToPxY(vLine[1].y)));
      ctx.stroke();
    }else{
      const ox=alignPx(fpToPxX(origin.x)), oy=alignPx(fpToPxY(origin.y));
      const half=FOV_DEG/2;
      for(const a of [-half, 0, half]){
        const angR=a * Math.PI/180;
        const x=Math.sin(angR)*rMax;
        const y=Math.cos(angR)*rMax;
        const end=offsetPoints(rotatePoints([{x,y}], ang), origin)[0];
        ctx.beginPath();
        ctx.moveTo(ox,oy);
        ctx.lineTo(alignPx(fpToPxX(end.x)), alignPx(fpToPxY(end.y)));
        ctx.stroke();
      }
    }

    ctx.globalAlpha=1;
    ctx.restore();
  }

  function drawSingleSensorOverlay2D(sensor){
    if(!sensor) return;
    const origin = {x:sensor.x,y:sensor.y};
    const ang = sensorAngle(sensor);
    const sZones = sensorZones(sensor);
    const activeDeviceId = placementDevice()?.device_id || selectedDevice?.device_id || null;
    const live = livePosFor(sensor.device_id);
    const mode=sensorInstallMode(sensor);
    const targetR = floorplanTargetRadius();
    const fovRange=sensorFovRange(sensor, mode);
    if(shouldShowFloorplanFov() && fovRange>0){
      ctx.save();
      drawFloorplanFov2DAt(fovRange, origin, sensor, mode);
      drawFloorplanFovGuides2DAt(fovRange, origin, sensor, mode);
      ctx.restore();
    }
    const isActiveSensor = activeDeviceId && sensor?.device_id === activeDeviceId;
    for(const key of ['1','2','3','excl']){
      const active = isActiveSensor && currentZone && key===currentZone;
      const style=zoneStyle(key,active);
      const pts=offsetPoints(rotatePoints(sZones[key], ang), origin);
      drawFloorplanPoly2D(pts, style);
    }
    const color = WALL_COLOR;
    const r = targetR;
    for (const n of [1, 2, 3, 4, 5]) {
      const p = live[n];
      if (!p || !Number.isFinite(p.x) || !Number.isFinite(p.y) || (p.x === 0 && p.y === 0)) continue;
      const rot = rotatePoints([{x:p.x,y:p.y}], ang)[0];
      const wx = clamp(rot.x + origin.x, FLOORPLAN_BOUNDS.xMin, FLOORPLAN_BOUNDS.xMax);
      const wy = clamp(rot.y + origin.y, FLOORPLAN_BOUNDS.yMin, FLOORPLAN_BOUNDS.yMax);
      const px = fpToPxX(wx);
      const py = fpToPxY(wy);
      ctx.beginPath();
      ctx.arc(px, py, targetR, 0, Math.PI * 2);
      ctx.fillStyle = color;
      ctx.globalAlpha = 0.9;
      ctx.fill();
    }
    ctx.globalAlpha=1;
    if(floorplanTool==='zone' && activeDeviceId && sensor.device_id===activeDeviceId && currentZone){
      const style = zoneStyle(currentZone,true);
      const pts = offsetPoints(rotatePoints(sZones[currentZone], ang), origin);
      const radius=wallHandleRadius();
      ctx.save();
      pts.forEach(p=>{
        const px=alignPx(fpToPxX(p.x)), py=alignPx(fpToPxY(p.y));
        ctx.beginPath();
        ctx.arc(px,py,radius,0,Math.PI*2);
        ctx.fillStyle=style.stroke;
        ctx.strokeStyle=WALL_HANDLE_SHADOW;
        ctx.lineWidth=hairline();
        ctx.fill();
        ctx.stroke();
      });
      ctx.restore();
    }
  }

  function drawFloorplanSensorOverlay2D(){
    const sensors = floorplanSensorsForOverlay();
    if(!sensors.length) return;
    sensors.forEach(drawSingleSensorOverlay2D);
  }

  function drawFloorplanSensorOverlay3D(){
    const sensors = floorplanSensorsForOverlay();
    if(!sensors.length) return;
    for(const sensor of sensors){
      const origin = {x:sensor.x, y:sensor.y};
      const mode=sensorInstallMode(sensor);
      const fovRange=sensorFovRange(sensor, mode);
      if(shouldShowFloorplanFov() && fovRange>0){
        ctx.save();
        drawFov3DAt(fovRange, origin, false, sensor, mode);
        drawFovGuides3DAt(fovRange, origin, sensor, mode);
        ctx.restore();
      }
      drawFloorplanZones3D(origin, sensor);
      drawFloorplanTargets3D(origin, sensor);
    }
  }

  function drawFov3DAt(range, origin, lighter=false, sensor=null, mode='side'){
    const r = clampFovRange(range, mode);
    if(!r || !origin) return;
    const rad  = Math.PI/180;
    const ang = sensorAngle(sensor);
    const cosA=Math.cos(ang), sinA=Math.sin(ang);
    const pts=[];
    if(mode==='top'){
      for(let a=0; a<=360; a+=3){
        const lx = r*Math.sin(a*rad);
        const lz = r*Math.cos(a*rad);
        const rx = lx*cosA - lz*sinA;
        const rz = lx*sinA + lz*cosA;
        pts.push({
          x: origin.x + rx,
          y: 0,
          z: origin.y + rz
        });
      }
    }else{
      const half = FOV_DEG/2;
      pts.push({x:origin.x,y:0,z:origin.y});
      for(let a=-half; a<=half; a+=3){
        const lx = r*Math.sin(a*rad);
        const lz = r*Math.cos(a*rad);
        const rx = lx*cosA - lz*sinA;
        const rz = lx*sinA + lz*cosA;
        pts.push({
          x: origin.x + rx,
          y: 0,
          z: origin.y + rz
        });
      }
      pts.push({x:origin.x,y:0,z:origin.y});
    }

    const baseColor = cssVar('--fov') || '#e6eaf1';
    ctx.save();
    ctx.beginPath();
    let first=true;
    for(const w of pts){
      const p=project3D(w.x,w.y,w.z);
      if(!p) continue;
      if(first){ ctx.moveTo(p.x,p.y); first=false; }
      else ctx.lineTo(p.x,p.y);
    }
    if(!first){
      ctx.closePath();
      ctx.globalAlpha=lighter?0.10:0.18;
      ctx.fillStyle=baseColor;
      ctx.fill();
    }
    ctx.globalAlpha=1;
    ctx.restore();
  }

  function drawFovGuides3DAt(range, origin, sensor=null, mode='side'){
    const rMax=clampFovRange(range, mode);
    if(rMax<=0 || !origin) return;
    const ang=sensorAngle(sensor);
    const cosA=Math.cos(ang), sinA=Math.sin(ang);
    ctx.save();
    ctx.lineWidth=Math.max(1, hairline()*1);
    ctx.strokeStyle=cssVar('--fov')||'#1e2431';
    ctx.globalAlpha=0.25;

    function toWorld(p){
      const rx=p.x*cosA - p.y*sinA;
      const rz=p.x*sinA + p.y*cosA;
      return {x: origin.x + rx, y: 0, z: origin.y + rz};
    }

    function strokeArc(range){
      const pts=makeFovArcPoints(range, mode);
      if(pts.length<2) return;
      ctx.beginPath();
      let first=true;
      for(const p of pts){
        const w=toWorld(p);
        const proj=project3D(w.x,w.y,w.z);
        if(!proj) continue;
        if(first){ ctx.moveTo(proj.x,proj.y); first=false; }
        else ctx.lineTo(proj.x,proj.y);
      }
      if(!first && mode==='top') ctx.closePath();
      if(!first) ctx.stroke();
    }

    for(let r=GRID;r<=rMax;r+=GRID){
      strokeArc(r);
    }

    function strokeLine3D(a,b){
      const wa=toWorld(a);
      const wb=toWorld(b);
      const pa=project3D(wa.x,wa.y,wa.z);
      const pb=project3D(wb.x,wb.y,wb.z);
      if(!pa || !pb) return;
      ctx.beginPath();
      ctx.moveTo(pa.x,pa.y);
      ctx.lineTo(pb.x,pb.y);
      ctx.stroke();
    }

    if(mode==='top'){
      strokeLine3D({x:-rMax,y:0},{x:rMax,y:0});
      strokeLine3D({x:0,y:-rMax},{x:0,y:rMax});
    }else{
      const half=FOV_DEG/2;
      for(const a of [-half, 0, half]){
        const angR=a * Math.PI/180;
        const x=Math.sin(angR)*rMax;
        const y=Math.cos(angR)*rMax;
        strokeLine3D({x:0,y:0},{x,y});
      }
    }

    ctx.globalAlpha=1;
    ctx.restore();
  }

  function drawFloorplanZones3D(origin, sensor=null){
    if(!origin) return;
    const ang = sensorAngle(sensor);
    const cosA=Math.cos(ang), sinA=Math.sin(ang);
    const rotateLocal=(pts)=> (pts||[]).map(p=>{
      const lx=p.x, lz=p.y;
      return {x: lx*cosA - lz*sinA, y: lx*sinA + lz*cosA};
    });
    const activeDeviceId = placementDevice()?.device_id || selectedDevice?.device_id || null;
    const isActiveSensor = activeDeviceId && sensor?.device_id === activeDeviceId;
    const sZones = sensorZones(sensor);
    const lines=[];
    for(const key of ['1','2','3','excl']){
      const pts = offsetPoints(rotateLocal(sZones[key]), origin);
      if(!pts || pts.length<2) continue;
      const active = isActiveSensor && currentZone && key===currentZone;
      lines.push({pts, style: zoneStyle(key, active)});
    }
    renderWalls3D(lines, WALL_HEIGHT_CM, {closed:true, caps:true});
  }

  function drawFloorplanTargets3D(origin, sensor=null){
    if(!origin) return;
    const ang = sensorAngle(sensor);
    const sensorCos=Math.cos(ang), sensorSin=Math.sin(ang);
    const live = livePosFor(sensor?.device_id);
    const faces = [];
    const color = WALL_COLOR;
    const SCALE = 1;

    function pushFace(verts) {
      const proj = verts.map(v => project3D(v.x, v.y, v.z));
      if (proj.some(p => !p)) return;
      const depth = proj.reduce((s, p) => s + p.z, 0) / proj.length;
      faces.push({ proj, depth });
    }

    for (const n of [1, 2, 3, 4, 5]) {
      const p = live[n];
      if (!p || !Number.isFinite(p.x) || !Number.isFinite(p.y)) continue;
      if (p.x === 0 && p.y === 0) continue;

      const lx = p.x;
      const lz = p.y;
      const rx = lx*sensorCos - lz*sensorSin;
      const rz = lx*sensorSin + lz*sensorCos;
      const wx = clamp(rx + origin.x, FLOORPLAN_BOUNDS.xMin, FLOORPLAN_BOUNDS.xMax);
      const wz = clamp(rz + origin.y, FLOORPLAN_BOUNDS.yMin, FLOORPLAN_BOUNDS.yMax);

      let angleRad = (Number.isFinite(p.heading) ? p.heading : 0) + ang;
      if(Number.isFinite(p.px) && Number.isFinite(p.py)){
        const prx = p.px*sensorCos - p.py*sensorSin;
        const prz = p.px*sensorSin + p.py*sensorCos;
        const dx = rx - prx;
        const dz = rz - prz;
        if(Math.hypot(dx,dz)>1e-3){
          angleRad = Math.atan2(dx,dz);
        }
      }
      const headingCos = Math.cos(angleRad);
      const headingSin = Math.sin(angleRad);

      for (const tri of HUMAN_TRIANGLES) {
        const v0 = tri[0];
        const v1 = tri[1];
        const v2 = tri[2];

        function transform(v) {
          const lx = v.x * SCALE;
          const ly = v.y * SCALE;
          const lz = v.z * SCALE;

          const rx = lx * headingCos + lz * headingSin;
          const rz = -lx * headingSin + lz * headingCos;

          return {
            x: wx + rx,
            y: ly,
            z: wz + rz
          };
        }

        const verts = [transform(v0), transform(v1), transform(v2)];
        pushFace(verts);
      }
    }

    faces.sort((a, b) => b.depth - a.depth);

    ctx.save();
    ctx.strokeStyle = color;
    ctx.fillStyle   = color;

    for (const f of faces) {
      ctx.beginPath();
      ctx.moveTo(f.proj[0].x, f.proj[0].y);
      for (let i = 1; i < f.proj.length; i++) {
        ctx.lineTo(f.proj[i].x, f.proj[i].y);
      }
      ctx.closePath();

      ctx.globalAlpha = 0.20;
      ctx.fill();

      ctx.globalAlpha = 0.4;
      ctx.lineWidth   = 0.25;
      ctx.stroke();
    }

    ctx.restore();

  }


  function softFovFactor(x,z,range,mode='side'){
    const r = Math.hypot(x,z);
    const ang = Math.atan2(x,z);
    const half = FOV_RAD * 0.5;

    const bandR = 30;
    const bandA = 5 * Math.PI/180;

    const absA = Math.abs(ang);

    let fRad;
    if(r <= range - bandR)      fRad = 1;
    else if(r >= range)         fRad = 0;
    else {
      const t = (range - r) / bandR;
      fRad = smoothstep01(t);
    }

    let fAng;
    if(mode==='top'){
      fAng = 1;
    }else if(absA <= half - bandA){
      fAng = 1;
    }else if(absA >= half){
      fAng = 0;
    }else{
      const t = (half - absA) / bandA;
      fAng = smoothstep01(t);
    }

    return fRad * fAng;
  }

  function softWorldFactor(x,z){
    const band = 30;
    let fx = 1, fz = 1;
    const b = baseBounds();

    if(x <= b.xMin) return 0;
    if(x < b.xMin + band){
      const t = (x - b.xMin) / band;
      fx *= smoothstep01(t);
    }
    if(x >= b.xMax) return 0;
    if(x > b.xMax - band){
      const t = (b.xMax - x) / band;
      fx *= smoothstep01(t);
    }

    if(z <= b.yMin) return 0;
    if(z < b.yMin + band){
      const t = (z - b.yMin) / band;
      fz *= smoothstep01(t);
    }
    if(z >= b.yMax) return 0;
    if(z > b.yMax - band){
      const t = (b.yMax - z) / band;
      fz *= smoothstep01(t);
    }

    return fx * fz;
  }

  function sampleFieldAt(arr, w, h, worldX, worldZ){
    const b = baseBounds();
    const worldW = b.xMax - b.xMin;
    const worldH = b.yMax - b.yMin;
    let u = (worldX - b.xMin) / worldW;
    let v = (worldZ - b.yMin) / worldH;
    if(u<0||u>1||v<0||v>1) return 0;
    const x = u*(w-1);
    const y = v*(h-1);
    const x0 = Math.floor(x), y0 = Math.floor(y);
    const x1 = Math.min(w-1,x0+1), y1 = Math.min(h-1,y0+1);
    const dx = x - x0, dy = y - y0;

    const i00 = y0*w + x0;
    const i10 = y0*w + x1;
    const i01 = y1*w + x0;
    const i11 = y1*w + x1;

    const v00 = arr[i00], v10 = arr[i10], v01 = arr[i01], v11 = arr[i11];

    const v0 = v00*(1-dx) + v10*dx;
    const v1 = v01*(1-dx) + v11*dx;
    return v0*(1-dy) + v1*dy;
  }

  function drawHeatmap3D(){
    if(viewMode!=='heatmap' || viewDim!=='3d') return;
    const cached = ensureHeatmapField();
    if(!cached) return;
    const {color,height,w,h} = cached;

    const scale = Math.min(HEATMAP3D_MAX_RES/w, HEATMAP3D_MAX_RES/h, 1);
    const gw = Math.max(2, Math.floor(w * scale));
    const gh = Math.max(2, Math.floor(h * scale));

    const vertices = Array.from({length:gh}, ()=>Array(gw));
    const maxR = fovMaxRange();
    const rDet = detRange>0 ? Math.min(detRange, maxR) : maxR;
    const b = baseBounds();
    const worldW = b.xMax - b.xMin;
    const worldH = b.yMax - b.yMin;

    for(let gy=0; gy<gh; gy++){
      const vz = b.yMin + (gy/(gh-1))*worldH;
      for(let gx=0; gx<gw; gx++){
        const vx = b.xMin + (gx/(gw-1))*worldW;

        const baseColor  = sampleFieldAt(color , w, h, vx, vz);
        let   baseHeight = baseColor>0 ? sampleFieldAt(height, w, h, vx, vz) : 0;

        const fFov   = softFovFactor(vx, vz, rDet, installMode);
        const fWorld = softWorldFactor(vx, vz);
        const f      = fFov * fWorld;

        const tColor  = baseColor  * f;
        const tHeight = baseHeight * f;

        const hCm = tHeight * HEATMAP_MAX_HEIGHT_CM;
        const proj = hCm>0 ? project3D(vx,hCm,vz) : project3D(vx,0,vz);
        vertices[gy][gx] = {
          sx: proj ? proj.x : null,
          sy: proj ? proj.y : null,
          depth: proj ? proj.z : Infinity,
          tColor,
          tHeight,
          worldX: vx,
          worldZ: vz
        };
      }
    }

    const tris=[];
    for(let gy=0; gy<gh-1; gy++){
      for(let gx=0; gx<gw-1; gx++){
        const v00 = vertices[gy][gx];
        const v10 = vertices[gy][gx+1];
        const v01 = vertices[gy+1][gx];
        const v11 = vertices[gy+1][gx+1];

        if(!v00 || !v10 || !v01 || !v11) continue;

        function pushTri(a,b,c){
          if(a.sx==null || b.sx==null || c.sx==null) return;
          const tAvg = (a.tColor + b.tColor + c.tColor)/3;
          if(tAvg<=0) return;
          const depth = (a.depth + b.depth + c.depth)/3;
          tris.push({a,b,c,t:tAvg,depth});
        }

        pushTri(v00,v10,v01);
        pushTri(v10,v11,v01);
      }
    }

    tris.sort((a,b)=>b.depth - a.depth);

    ctx.save();
    for(const tri of tris){
      const t = tri.t;
      const idx = Math.min(255,(t*255)|0)*4;
      const rCol = PALETTE[idx];
      const gCol = PALETTE[idx+1];
      const bCol = PALETTE[idx+2];
      const alpha = 0.25 + 0.55*t;

      ctx.beginPath();
      ctx.moveTo(tri.a.sx,tri.a.sy);
      ctx.lineTo(tri.b.sx,tri.b.sy);
      ctx.lineTo(tri.c.sx,tri.c.sy);
      ctx.closePath();
      ctx.fillStyle = `rgb(${rCol},${gCol},${bCol})`;
      ctx.globalAlpha = alpha;
      ctx.fill();
    }
    ctx.restore();
  }

  function renderWalls3D(lines, wallH, {closed=false,caps=false}={}){
    if(!lines || !lines.length) return;
    const walls=[];
    const segments=[];
    const nodeKey=(p)=>`${p.x.toFixed(2)},${p.y.toFixed(2)}`;
    const deg=new Map();

    ctx.save();
    ctx.lineJoin='miter';
    ctx.lineCap='butt';
    ctx.miterLimit=2;

    if(caps){
      for(const {pts,style} of lines){
        if(!pts || pts.length<2) continue;
        ctx.beginPath();
        let first=true;
        for(const pt of pts){
          const p=project3D(pt.x,0,pt.y);
          if(!p) continue;
          if(first){ctx.moveTo(p.x,p.y); first=false;}
          else ctx.lineTo(p.x,p.y);
        }
        if(!first && closed && pts.length>=3) ctx.closePath();
        if(style?.fill){
          ctx.globalAlpha=(style.fillAlpha ?? 1)*0.9;
          ctx.fillStyle=style.fill;
          ctx.fill();
        }
        if(style?.stroke){
          ctx.globalAlpha=1;
          ctx.lineWidth=style.width ?? 2;
          ctx.strokeStyle=style.stroke;
          ctx.stroke();
        }
      }
      ctx.globalAlpha=1;
    }

    for(const {pts} of lines){
      if(!pts || pts.length<2) continue;
      const n=pts.length;
      const limit=closed ? n : n-1;
      for(let i=0;i<limit;i++){
        const j=(i+1)%n;
        const k0=nodeKey(pts[i]);
        const k1=nodeKey(pts[j]);
        deg.set(k0,(deg.get(k0)||0)+1);
        deg.set(k1,(deg.get(k1)||0)+1);
      }
    }

    for(const {pts,style} of lines){
      if(!pts || pts.length<2 || !style) continue;
      const n=pts.length;
      const limit=closed ? n : n-1;
      for(let i=0;i<limit;i++){
        const j=(i+1)%n;
        const p0=pts[i], p1=pts[j];
        const b0=project3D(p0.x,0,p0.y);
        const b1=project3D(p1.x,0,p1.y);
        const t0=project3D(p0.x,wallH,p0.y);
        const t1=project3D(p1.x,wallH,p1.y);
        if(!b0 || !b1 || !t0 || !t1) continue;
        const segIdx=segments.length;
        segments.push({p0,p1,segIdx});
        const depth=(b0.z + b1.z + t0.z + t1.z)/4;
        const d0=deg.get(nodeKey(p0))||0;
        const d1=deg.get(nodeKey(p1))||0;
        walls.push({b0,b1,t0,t1,style,depth,p0,p1,drawV0:d0<=2,drawV1:d1<=2,segIdx});
      }
    }

    const touchesOtherInterior=(pt,skipSegIdx)=>{
      for(const seg of segments){
        if(seg.segIdx===skipSegIdx) continue;
        if(pointOnSegmentInterior(pt, seg.p0, seg.p1)) return true;
      }
      return false;
    };

    walls.sort((a,b)=>b.depth - a.depth);
    for(const w of walls){
      const style=w.style;
      if(style.fill){
        ctx.beginPath();
        ctx.moveTo(w.b0.x,w.b0.y);
        ctx.lineTo(w.b1.x,w.b1.y);
        ctx.lineTo(w.t1.x,w.t1.y);
        ctx.lineTo(w.t0.x,w.t0.y);
        ctx.closePath();
        ctx.fillStyle=style.fill;
        ctx.globalAlpha=(style.fillAlpha ?? 1)*0.45;
        ctx.fill();
      }
      if(style.stroke){
        ctx.globalAlpha=0.9;
        ctx.lineWidth=style.width ?? 2;
        ctx.strokeStyle=style.stroke;
        ctx.beginPath();
        ctx.moveTo(w.b0.x,w.b0.y);
        ctx.lineTo(w.b1.x,w.b1.y);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(w.t0.x,w.t0.y);
        ctx.lineTo(w.t1.x,w.t1.y);
        ctx.stroke();
        if(w.drawV0 && !touchesOtherInterior(w.p0, w.segIdx)){
          ctx.beginPath();
          ctx.moveTo(w.b0.x,w.b0.y);
          ctx.lineTo(w.t0.x,w.t0.y);
          ctx.stroke();
        }
        if(w.drawV1 && !touchesOtherInterior(w.p1, w.segIdx)){
          ctx.beginPath();
          ctx.moveTo(w.b1.x,w.b1.y);
          ctx.lineTo(w.t1.x,w.t1.y);
          ctx.stroke();
        }
      }
    }

    ctx.globalAlpha=1;
    ctx.restore();
  }

  function drawZones3D(){
    const wallH = WALL_HEIGHT_CM;
    const lines=[];
    for(const key of ['1','2','3','excl']){
      const pts=zones[key];
      if(!pts || pts.length<2) continue;
      const active=currentZone && key===currentZone;
      lines.push({pts, style: zoneStyle(key, active)});
    }
    renderWalls3D(lines, wallH, {closed:true, caps:true});
  }

  function drawFloorplanWalls3D(){
    if(!floorplanPolylines.length) return;
    const wallH = FLOORPLAN_WALL_HEIGHT_CM;
    const style = wallStyle();
    const lines = floorplanPolylines
      .filter(line => line && line.length>=2)
      .map(pts => ({pts, style}));
    renderWalls3D(lines, wallH, {closed:false, caps:false});
  }

HUMAN_TRIANGLES = [
  [{x:-7.61, y:172.57, z:-8.41}, {x:-7.9, y:165.93, z:-4.32}, {x:-2.67, y:161.54, z:-10.64}],
  [{x:-13.86, y:0.0, z:12.08}, {x:-16.48, y:2.9, z:10.58}, {x:-13.78, y:4.9, z:3.64}],
  [{x:-21.86, y:0.0, z:9.58}, {x:-16.48, y:2.9, z:10.58}, {x:-13.86, y:0.0, z:12.08}],
  [{x:-6.06, y:159.44, z:-2.83}, {x:-2.67, y:161.54, z:-10.64}, {x:-7.9, y:165.93, z:-4.32}],
  [{x:-2.67, y:161.54, z:-10.64}, {x:0.42, y:174.34, z:-12.68}, {x:-7.61, y:172.57, z:-8.41}],
  [{x:-11.42, y:15.46, z:-8.64}, {x:-11.49, y:0.0, z:-3.66}, {x:-14.98, y:11.23, z:-4.79}],
  [{x:-11.41, y:0.0, z:-11.73}, {x:-11.49, y:0.0, z:-3.66}, {x:-13.31, y:12.02, z:-12.33}],
  [{x:-13.31, y:12.02, z:-12.33}, {x:-11.49, y:0.0, z:-3.66}, {x:-11.42, y:15.46, z:-8.64}],
  [{x:-5.1, y:178.24, z:-4.79}, {x:-7.61, y:172.57, z:-8.41}, {x:0.42, y:174.34, z:-12.68}],
  [{x:0.42, y:180.0, z:-2.63}, {x:-5.1, y:178.24, z:-4.79}, {x:0.42, y:174.34, z:-12.68}],
  [{x:5.7, y:59.8, z:1.13}, {x:12.19, y:42.1, z:-1.96}, {x:5.78, y:50.98, z:-4.62}],
  [{x:-6.7, y:175.25, z:3.19}, {x:-5.79, y:165.74, z:5.99}, {x:-7.9, y:165.93, z:-4.32}],
  [{x:-7.61, y:172.57, z:-8.41}, {x:-6.7, y:175.25, z:3.19}, {x:-7.9, y:165.93, z:-4.32}],
  [{x:16.97, y:53.05, z:-5.05}, {x:14.36, y:86.8, z:-11.24}, {x:13.19, y:52.92, z:-11.13}],
  [{x:-6.7, y:175.25, z:3.19}, {x:-7.61, y:172.57, z:-8.41}, {x:-5.1, y:178.24, z:-4.79}],
  [{x:-5.1, y:178.24, z:-4.79}, {x:0.42, y:180.0, z:-2.63}, {x:-6.7, y:175.25, z:3.19}],
  [{x:0.69, y:168.11, z:9.89}, {x:0.5, y:175.78, z:6.9}, {x:7.25, y:175.34, z:1.67}],
  [{x:14.36, y:86.8, z:-11.24}, {x:6.19, y:92.33, z:-13.85}, {x:11.53, y:77.33, z:-10.97}],
  [{x:3.43, y:81.72, z:-11.37}, {x:11.53, y:77.33, z:-10.97}, {x:6.19, y:92.33, z:-13.85}],
  [{x:-3.02, y:154.6, z:-10.54}, {x:-18.73, y:147.28, z:-4.81}, {x:-17.75, y:141.37, z:-11.91}],
  [{x:-3.45, y:154.98, z:2.21}, {x:-2.54, y:148.17, z:0.54}, {x:-6.09, y:151.19, z:-4.18}],
  [{x:-18.73, y:147.28, z:-4.81}, {x:-3.02, y:154.6, z:-10.54}, {x:-6.09, y:151.19, z:-4.18}],
  [{x:-3.02, y:154.6, z:-10.54}, {x:-6.06, y:159.44, z:-2.83}, {x:-6.09, y:151.19, z:-4.18}],
  [{x:-2.12, y:84.1, z:7.3}, {x:8.85, y:91.09, z:9.28}, {x:2.25, y:83.51, z:5.28}],
  [{x:-7.9, y:165.93, z:-4.32}, {x:-5.79, y:165.74, z:5.99}, {x:-6.06, y:159.44, z:-2.83}],
  [{x:-17.75, y:141.37, z:-11.91}, {x:3.33, y:147.61, z:-14.57}, {x:-3.02, y:154.6, z:-10.54}],
  [{x:14.36, y:86.8, z:-11.24}, {x:18.54, y:73.06, z:1.34}, {x:13.14, y:109.79, z:-2.09}],
  [{x:-2.67, y:161.54, z:-10.64}, {x:-6.06, y:159.44, z:-2.83}, {x:-3.02, y:154.6, z:-10.54}],
  [{x:-6.8, y:137.5, z:8.41}, {x:-18.73, y:147.28, z:-4.81}, {x:-2.54, y:148.17, z:0.54}],
  [{x:-6.09, y:151.19, z:-4.18}, {x:-2.54, y:148.17, z:0.54}, {x:-18.73, y:147.28, z:-4.81}],
  [{x:9.95, y:139.4, z:6.21}, {x:3.51, y:131.96, z:10.76}, {x:4.07, y:147.56, z:0.76}],
  [{x:3.43, y:81.72, z:-11.37}, {x:0.64, y:85.75, z:-12.63}, {x:-0.29, y:81.68, z:-1.88}],
  [{x:6.19, y:92.33, z:-13.85}, {x:0.64, y:85.75, z:-12.63}, {x:3.43, y:81.72, z:-11.37}],
  [{x:0.64, y:85.75, z:-12.63}, {x:-2.56, y:81.23, z:-11.18}, {x:-0.29, y:81.68, z:-1.88}],
  [{x:11.97, y:130.4, z:7.73}, {x:3.51, y:131.96, z:10.76}, {x:9.95, y:139.4, z:6.21}],
  [{x:28.18, y:111.52, z:-9.83}, {x:21.09, y:135.11, z:-11.24}, {x:17.95, y:131.19, z:-11.0}],
  [{x:27.69, y:129.55, z:-5.45}, {x:20.74, y:143.49, z:-8.79}, {x:21.09, y:135.11, z:-11.24}],
  [{x:21.09, y:135.11, z:-11.24}, {x:9.75, y:134.32, z:-16.79}, {x:17.95, y:131.19, z:-11.0}],
  [{x:20.74, y:143.49, z:-8.79}, {x:9.75, y:134.32, z:-16.79}, {x:21.09, y:135.11, z:-11.24}],
  [{x:29.4, y:117.63, z:-0.4}, {x:23.5, y:116.08, z:-2.73}, {x:18.91, y:132.39, z:0.83}],
  [{x:18.57, y:140.73, z:-0.07}, {x:18.91, y:132.39, z:0.83}, {x:11.97, y:130.4, z:7.73}],
  [{x:16.9, y:129.04, z:-8.16}, {x:11.97, y:130.4, z:7.73}, {x:18.91, y:132.39, z:0.83}],
  [{x:11.97, y:130.4, z:7.73}, {x:9.95, y:139.4, z:6.21}, {x:18.57, y:140.73, z:-0.07}],
  [{x:13.19, y:52.92, z:-11.13}, {x:17.93, y:32.42, z:-13.03}, {x:16.97, y:53.05, z:-5.05}],
  [{x:19.44, y:31.72, z:-8.19}, {x:16.97, y:53.05, z:-5.05}, {x:17.93, y:32.42, z:-13.03}],
  [{x:5.78, y:50.98, z:-4.62}, {x:8.26, y:42.01, z:-7.97}, {x:9.53, y:46.2, z:-11.28}],
  [{x:16.97, y:53.05, z:-5.05}, {x:19.44, y:31.72, z:-8.19}, {x:15.43, y:42.67, z:-2.11}],
  [{x:12.19, y:42.1, z:-1.96}, {x:8.26, y:42.01, z:-7.97}, {x:5.78, y:50.98, z:-4.62}],
  [{x:13.19, y:52.92, z:-11.13}, {x:12.78, y:32.3, z:-15.34}, {x:17.93, y:32.42, z:-13.03}],
  [{x:9.53, y:46.2, z:-11.28}, {x:12.78, y:32.3, z:-15.34}, {x:13.19, y:52.92, z:-11.13}],
  [{x:-13.17, y:52.92, z:-11.13}, {x:-14.84, y:86.67, z:-10.51}, {x:-16.96, y:53.05, z:-5.05}],
  [{x:12.78, y:32.3, z:-15.34}, {x:9.53, y:46.2, z:-11.28}, {x:7.94, y:30.17, z:-10.24}],
  [{x:8.26, y:42.01, z:-7.97}, {x:7.94, y:30.17, z:-10.24}, {x:9.53, y:46.2, z:-11.28}],
  [{x:12.19, y:42.1, z:-1.96}, {x:7.94, y:30.17, z:-10.24}, {x:8.26, y:42.01, z:-7.97}],
  [{x:-15.41, y:42.67, z:-2.11}, {x:-19.42, y:31.72, z:-8.19}, {x:-16.96, y:53.05, z:-5.05}],
  [{x:13.33, y:12.02, z:-12.33}, {x:12.78, y:32.3, z:-15.34}, {x:7.94, y:30.17, z:-10.24}],
  [{x:-5.6, y:51.18, z:-4.28}, {x:-12.17, y:42.15, z:-1.95}, {x:-5.55, y:60.2, z:1.32}],
  [{x:17.93, y:32.42, z:-13.03}, {x:12.78, y:32.3, z:-15.34}, {x:13.33, y:12.02, z:-12.33}],
  [{x:13.33, y:12.02, z:-12.33}, {x:7.94, y:30.17, z:-10.24}, {x:11.44, y:15.46, z:-8.64}],
  [{x:-8.24, y:42.01, z:-7.97}, {x:-5.6, y:51.18, z:-4.28}, {x:-9.51, y:46.2, z:-11.28}],
  [{x:-12.76, y:32.3, z:-15.34}, {x:-9.51, y:46.2, z:-11.28}, {x:-13.17, y:52.92, z:-11.13}],
  [{x:-15.41, y:42.67, z:-2.11}, {x:-12.17, y:42.15, z:-1.95}, {x:-14.98, y:11.23, z:-4.79}],
  [{x:13.88, y:0.0, z:12.01}, {x:13.53, y:4.3, z:4.43}, {x:16.37, y:3.4, z:9.94}],
  [{x:13.53, y:4.3, z:4.43}, {x:11.51, y:0.0, z:-3.66}, {x:14.87, y:10.9, z:-4.45}],
  [{x:11.51, y:0.0, z:-3.66}, {x:13.53, y:4.3, z:4.43}, {x:13.88, y:0.0, z:12.01}],
  [{x:-8.24, y:42.01, z:-7.97}, {x:-12.17, y:42.15, z:-1.95}, {x:-5.6, y:51.18, z:-4.28}],
  [{x:-17.91, y:32.42, z:-13.03}, {x:-16.96, y:53.05, z:-5.05}, {x:-19.42, y:31.72, z:-8.19}],
  [{x:14.87, y:10.9, z:-4.45}, {x:12.19, y:42.1, z:-1.96}, {x:15.43, y:42.67, z:-2.11}],
  [{x:-13.17, y:52.92, z:-11.13}, {x:-16.96, y:53.05, z:-5.05}, {x:-17.91, y:32.42, z:-13.03}],
  [{x:-13.17, y:52.92, z:-11.13}, {x:-17.91, y:32.42, z:-13.03}, {x:-12.76, y:32.3, z:-15.34}],
  [{x:13.33, y:12.02, z:-12.33}, {x:11.44, y:15.46, z:-8.64}, {x:11.51, y:0.0, z:-3.66}],
  [{x:11.43, y:0.0, z:-11.73}, {x:13.33, y:12.02, z:-12.33}, {x:11.51, y:0.0, z:-3.66}],
  [{x:-6.08, y:91.58, z:-14.06}, {x:-11.13, y:77.7, z:-10.99}, {x:-2.56, y:81.23, z:-11.18}],
  [{x:11.43, y:0.0, z:-11.73}, {x:16.44, y:0.0, z:-13.34}, {x:13.33, y:12.02, z:-12.33}],
  [{x:-11.13, y:77.7, z:-10.99}, {x:-6.08, y:91.58, z:-14.06}, {x:-14.84, y:86.67, z:-10.51}],
  [{x:11.51, y:0.0, z:-3.66}, {x:11.44, y:15.46, z:-8.64}, {x:14.87, y:10.9, z:-4.45}],
  [{x:-6.08, y:91.58, z:-14.06}, {x:-2.56, y:81.23, z:-11.18}, {x:0.64, y:85.75, z:-12.63}],
  [{x:11.54, y:73.59, z:7.98}, {x:2.25, y:83.51, z:5.28}, {x:8.85, y:91.09, z:9.28}],
  [{x:13.19, y:52.92, z:-11.13}, {x:11.53, y:77.33, z:-10.97}, {x:3.43, y:81.72, z:-11.37}],
  [{x:9.53, y:46.2, z:-11.28}, {x:13.19, y:52.92, z:-11.13}, {x:3.43, y:81.72, z:-11.37}],
  [{x:14.36, y:86.8, z:-11.24}, {x:11.53, y:77.33, z:-10.97}, {x:13.19, y:52.92, z:-11.13}],
  [{x:5.78, y:50.98, z:-4.62}, {x:-0.29, y:81.68, z:-1.88}, {x:2.25, y:83.51, z:5.28}],
  [{x:11.54, y:73.59, z:7.98}, {x:8.85, y:91.09, z:9.28}, {x:18.54, y:73.06, z:1.34}],
  [{x:-2.12, y:84.1, z:7.3}, {x:2.25, y:83.51, z:5.28}, {x:-0.29, y:81.68, z:-1.88}],
  [{x:16.97, y:53.05, z:-5.05}, {x:18.54, y:73.06, z:1.34}, {x:14.36, y:86.8, z:-11.24}],
  [{x:15.43, y:42.67, z:-2.11}, {x:18.54, y:73.06, z:1.34}, {x:16.97, y:53.05, z:-5.05}],
  [{x:3.43, y:81.72, z:-11.37}, {x:-0.29, y:81.68, z:-1.88}, {x:9.53, y:46.2, z:-11.28}],
  [{x:5.78, y:50.98, z:-4.62}, {x:9.53, y:46.2, z:-11.28}, {x:-0.29, y:81.68, z:-1.88}],
  [{x:12.19, y:42.1, z:-1.96}, {x:5.7, y:59.8, z:1.13}, {x:11.54, y:73.59, z:7.98}],
  [{x:-5.55, y:60.2, z:1.32}, {x:-2.12, y:84.1, z:7.3}, {x:-0.29, y:81.68, z:-1.88}],
  [{x:11.54, y:73.59, z:7.98}, {x:5.7, y:59.8, z:1.13}, {x:2.25, y:83.51, z:5.28}],
  [{x:18.54, y:73.06, z:1.34}, {x:12.19, y:42.1, z:-1.96}, {x:11.54, y:73.59, z:7.98}],
  [{x:18.54, y:73.06, z:1.34}, {x:15.43, y:42.67, z:-2.11}, {x:12.19, y:42.1, z:-1.96}],
  [{x:5.78, y:50.98, z:-4.62}, {x:2.25, y:83.51, z:5.28}, {x:5.7, y:59.8, z:1.13}],
  [{x:36.91, y:82.3, z:-0.36}, {x:35.69, y:93.76, z:-0.06}, {x:34.8, y:92.64, z:-3.71}],
  [{x:31.73, y:92.65, z:-3.16}, {x:33.37, y:83.32, z:-2.28}, {x:34.8, y:92.64, z:-3.71}],
  [{x:-2.56, y:81.23, z:-11.18}, {x:-11.13, y:77.7, z:-10.99}, {x:-13.17, y:52.92, z:-11.13}],
  [{x:-13.17, y:52.92, z:-11.13}, {x:-11.13, y:77.7, z:-10.99}, {x:-14.84, y:86.67, z:-10.51}],
  [{x:-13.17, y:52.92, z:-11.13}, {x:-9.51, y:46.2, z:-11.28}, {x:-2.56, y:81.23, z:-11.18}],
  [{x:4.07, y:147.56, z:0.76}, {x:-6.8, y:137.5, z:8.41}, {x:-2.54, y:148.17, z:0.54}],
  [{x:-5.79, y:165.74, z:5.99}, {x:0.55, y:156.87, z:8.06}, {x:-3.45, y:154.98, z:2.21}],
  [{x:-6.06, y:159.44, z:-2.83}, {x:-5.79, y:165.74, z:5.99}, {x:-3.45, y:154.98, z:2.21}],
  [{x:-6.09, y:151.19, z:-4.18}, {x:-6.06, y:159.44, z:-2.83}, {x:-3.45, y:154.98, z:2.21}],
  [{x:0.55, y:156.87, z:8.06}, {x:4.28, y:155.17, z:2.21}, {x:-3.45, y:154.98, z:2.21}],
  [{x:34.96, y:87.23, z:4.74}, {x:32.02, y:84.79, z:2.22}, {x:33.29, y:89.54, z:4.14}],
  [{x:33.29, y:89.54, z:4.14}, {x:31.92, y:94.01, z:1.43}, {x:35.69, y:93.76, z:-0.06}],
  [{x:34.96, y:87.23, z:4.74}, {x:33.29, y:89.54, z:4.14}, {x:35.69, y:93.76, z:-0.06}],
  [{x:-20.34, y:140.73, z:-0.07}, {x:-24.79, y:138.1, z:-5.73}, {x:-18.73, y:147.28, z:-4.81}],
  [{x:-18.73, y:147.28, z:-4.81}, {x:-24.79, y:138.1, z:-5.73}, {x:-17.75, y:141.37, z:-11.91}],
  [{x:34.8, y:92.64, z:-3.71}, {x:35.69, y:93.76, z:-0.06}, {x:32.23, y:114.01, z:-4.06}],
  [{x:35.69, y:93.76, z:-0.06}, {x:37.07, y:80.69, z:4.7}, {x:34.96, y:87.23, z:4.74}],
  [{x:35.56, y:79.58, z:4.79}, {x:32.02, y:84.79, z:2.22}, {x:34.96, y:87.23, z:4.74}],
  [{x:35.24, y:79.42, z:1.54}, {x:32.02, y:84.79, z:2.22}, {x:35.56, y:79.58, z:4.79}],
  [{x:37.07, y:80.69, z:4.7}, {x:35.56, y:79.58, z:4.79}, {x:34.96, y:87.23, z:4.74}],
  [{x:36.91, y:82.3, z:-0.36}, {x:33.37, y:83.32, z:-2.28}, {x:34.88, y:80.56, z:-1.02}],
  [{x:35.69, y:93.76, z:-0.06}, {x:36.91, y:82.3, z:-0.36}, {x:37.07, y:80.69, z:4.7}],
  [{x:33.29, y:89.54, z:4.14}, {x:32.02, y:84.79, z:2.22}, {x:31.92, y:94.01, z:1.43}],
  [{x:32.02, y:84.79, z:2.22}, {x:35.24, y:79.42, z:1.54}, {x:34.88, y:80.56, z:-1.02}],
  [{x:35.24, y:79.42, z:1.54}, {x:35.56, y:79.58, z:4.79}, {x:37.07, y:80.69, z:4.7}],
  [{x:34.8, y:92.64, z:-3.71}, {x:33.37, y:83.32, z:-2.28}, {x:36.91, y:82.3, z:-0.36}],
  [{x:-5.55, y:60.2, z:1.32}, {x:-0.29, y:81.68, z:-1.88}, {x:-5.6, y:51.18, z:-4.28}],
  [{x:-0.29, y:81.68, z:-1.88}, {x:-2.56, y:81.23, z:-11.18}, {x:-9.51, y:46.2, z:-11.28}],
  [{x:-0.29, y:81.68, z:-1.88}, {x:-9.51, y:46.2, z:-11.28}, {x:-5.6, y:51.18, z:-4.28}],
  [{x:-18.52, y:73.06, z:1.33}, {x:-16.96, y:53.05, z:-5.05}, {x:-14.84, y:86.67, z:-10.51}],
  [{x:-11.52, y:73.59, z:7.98}, {x:-5.55, y:60.2, z:1.32}, {x:-12.17, y:42.15, z:-1.95}],
  [{x:-11.52, y:73.59, z:7.98}, {x:-12.17, y:42.15, z:-1.95}, {x:-18.52, y:73.06, z:1.33}],
  [{x:-24.79, y:138.1, z:-5.73}, {x:-31.48, y:115.81, z:-5.59}, {x:-17.75, y:141.37, z:-11.91}],
  [{x:-17.75, y:141.37, z:-11.91}, {x:-31.48, y:115.81, z:-5.59}, {x:-28.71, y:112.12, z:-9.14}],
  [{x:-2.12, y:84.1, z:7.3}, {x:-11.52, y:73.59, z:7.98}, {x:-13.08, y:95.32, z:6.43}],
  [{x:-18.52, y:73.06, z:1.33}, {x:-12.17, y:42.15, z:-1.95}, {x:-15.41, y:42.67, z:-2.11}],
  [{x:-16.96, y:53.05, z:-5.05}, {x:-18.52, y:73.06, z:1.33}, {x:-15.41, y:42.67, z:-2.11}],
  [{x:-18.52, y:73.06, z:1.33}, {x:-13.08, y:95.32, z:6.43}, {x:-11.52, y:73.59, z:7.98}],
  [{x:-28.22, y:117.11, z:-2.22}, {x:-31.48, y:115.81, z:-5.59}, {x:-24.79, y:138.1, z:-5.73}],
  [{x:-2.12, y:84.1, z:7.3}, {x:-5.55, y:60.2, z:1.32}, {x:-11.52, y:73.59, z:7.98}],
  [{x:-19.2, y:131.29, z:0.95}, {x:-28.22, y:117.11, z:-2.22}, {x:-24.79, y:138.1, z:-5.73}],
  [{x:11.36, y:111.23, z:5.69}, {x:11.97, y:130.4, z:7.73}, {x:16.9, y:129.04, z:-8.16}],
  [{x:-16.96, y:128.87, z:-8.25}, {x:-24.05, y:116.19, z:-2.87}, {x:-19.2, y:131.29, z:0.95}],
  [{x:-28.71, y:112.12, z:-9.14}, {x:-18.63, y:132.27, z:-11.45}, {x:-17.75, y:141.37, z:-11.91}],
  [{x:-8.69, y:111.57, z:-8.47}, {x:8.86, y:112.13, z:-8.49}, {x:-9.07, y:133.45, z:-16.92}],
  [{x:-9.07, y:133.45, z:-16.92}, {x:-13.01, y:123.05, z:-11.22}, {x:-8.69, y:111.57, z:-8.47}],
  [{x:8.86, y:112.13, z:-8.49}, {x:17.95, y:131.19, z:-11.0}, {x:9.75, y:134.32, z:-16.79}],
  [{x:17.95, y:131.19, z:-11.0}, {x:8.86, y:112.13, z:-8.49}, {x:16.9, y:129.04, z:-8.16}],
  [{x:3.51, y:131.96, z:10.76}, {x:11.97, y:130.4, z:7.73}, {x:11.36, y:111.23, z:5.69}],
  [{x:18.91, y:132.39, z:0.83}, {x:23.5, y:116.08, z:-2.73}, {x:16.9, y:129.04, z:-8.16}],
  [{x:-16.96, y:128.87, z:-8.25}, {x:-13.01, y:123.05, z:-11.22}, {x:-18.63, y:132.27, z:-11.45}],
  [{x:-16.96, y:128.87, z:-8.25}, {x:-13.35, y:109.79, z:-2.09}, {x:-13.01, y:123.05, z:-11.22}],
  [{x:29.4, y:117.63, z:-0.4}, {x:18.91, y:132.39, z:0.83}, {x:18.57, y:140.73, z:-0.07}],
  [{x:29.4, y:117.63, z:-0.4}, {x:18.57, y:140.73, z:-0.07}, {x:27.69, y:129.55, z:-5.45}],
  [{x:-13.35, y:109.79, z:-2.09}, {x:-16.96, y:128.87, z:-8.25}, {x:-11.56, y:111.27, z:5.8}],
  [{x:27.69, y:129.55, z:-5.45}, {x:21.09, y:135.11, z:-11.24}, {x:28.18, y:111.52, z:-9.83}],
  [{x:-14.84, y:86.67, z:-10.51}, {x:-13.35, y:109.79, z:-2.09}, {x:-18.52, y:73.06, z:1.33}],
  [{x:13.14, y:109.79, z:-2.09}, {x:16.9, y:129.04, z:-8.16}, {x:8.86, y:112.13, z:-8.49}],
  [{x:-16.96, y:128.87, z:-8.25}, {x:-18.63, y:132.27, z:-11.45}, {x:-28.71, y:112.12, z:-9.14}],
  [{x:8.85, y:91.09, z:9.28}, {x:5.14, y:105.01, z:9.27}, {x:11.36, y:111.23, z:5.69}],
  [{x:8.85, y:91.09, z:9.28}, {x:11.36, y:111.23, z:5.69}, {x:18.54, y:73.06, z:1.34}],
  [{x:-2.12, y:84.1, z:7.3}, {x:5.14, y:105.01, z:9.27}, {x:8.85, y:91.09, z:9.28}],
  [{x:-6.08, y:91.58, z:-14.06}, {x:-9.66, y:103.11, z:-9.98}, {x:-14.84, y:86.67, z:-10.51}],
  [{x:13.14, y:109.79, z:-2.09}, {x:18.54, y:73.06, z:1.34}, {x:11.36, y:111.23, z:5.69}],
  [{x:13.14, y:109.79, z:-2.09}, {x:11.36, y:111.23, z:5.69}, {x:16.9, y:129.04, z:-8.16}],
  [{x:5.14, y:105.01, z:9.27}, {x:-3.08, y:110.12, z:10.2}, {x:3.51, y:131.96, z:10.76}],
  [{x:-13.35, y:109.79, z:-2.09}, {x:-9.66, y:103.11, z:-9.98}, {x:-8.69, y:111.57, z:-8.47}],
  [{x:11.36, y:111.23, z:5.69}, {x:5.14, y:105.01, z:9.27}, {x:3.51, y:131.96, z:10.76}],
  [{x:-14.84, y:86.67, z:-10.51}, {x:-9.66, y:103.11, z:-9.98}, {x:-13.35, y:109.79, z:-2.09}],
  [{x:-0.22, y:99.05, z:-11.54}, {x:6.19, y:92.33, z:-13.85}, {x:9.68, y:103.12, z:-9.97}],
  [{x:9.68, y:103.12, z:-9.97}, {x:6.19, y:92.33, z:-13.85}, {x:14.36, y:86.8, z:-11.24}],
  [{x:-13.01, y:123.05, z:-11.22}, {x:-13.35, y:109.79, z:-2.09}, {x:-8.69, y:111.57, z:-8.47}],
  [{x:8.86, y:112.13, z:-8.49}, {x:9.68, y:103.12, z:-9.97}, {x:13.14, y:109.79, z:-2.09}],
  [{x:14.36, y:86.8, z:-11.24}, {x:13.14, y:109.79, z:-2.09}, {x:9.68, y:103.12, z:-9.97}],
  [{x:12.19, y:42.1, z:-1.96}, {x:14.87, y:10.9, z:-4.45}, {x:7.94, y:30.17, z:-10.24}],
  [{x:11.44, y:15.46, z:-8.64}, {x:7.94, y:30.17, z:-10.24}, {x:14.87, y:10.9, z:-4.45}],
  [{x:16.44, y:0.0, z:-13.34}, {x:17.58, y:9.81, z:-9.1}, {x:13.33, y:12.02, z:-12.33}],
  [{x:-3.08, y:110.12, z:10.2}, {x:5.14, y:105.01, z:9.27}, {x:-2.12, y:84.1, z:7.3}],
  [{x:28.18, y:111.52, z:-9.83}, {x:17.95, y:131.19, z:-11.0}, {x:16.9, y:129.04, z:-8.16}],
  [{x:19.42, y:4.3, z:0.32}, {x:13.53, y:4.3, z:4.43}, {x:14.87, y:10.9, z:-4.45}],
  [{x:23.5, y:116.08, z:-2.73}, {x:31.73, y:92.65, z:-3.16}, {x:28.18, y:111.52, z:-9.83}],
  [{x:31.73, y:92.65, z:-3.16}, {x:34.8, y:92.64, z:-3.71}, {x:28.18, y:111.52, z:-9.83}],
  [{x:19.42, y:4.3, z:0.32}, {x:16.37, y:3.4, z:9.94}, {x:13.53, y:4.3, z:4.43}],
  [{x:-11.49, y:0.0, z:-3.66}, {x:-19.45, y:0.0, z:-3.11}, {x:-13.86, y:0.0, z:12.08}],
  [{x:11.43, y:0.0, z:-11.73}, {x:19.47, y:0.0, z:-3.11}, {x:16.44, y:0.0, z:-13.34}],
  [{x:19.47, y:0.0, z:-3.11}, {x:11.43, y:0.0, z:-11.73}, {x:11.51, y:0.0, z:-3.66}],
  [{x:19.47, y:0.0, z:-3.11}, {x:11.51, y:0.0, z:-3.66}, {x:13.88, y:0.0, z:12.01}],
  [{x:28.18, y:111.52, z:-9.83}, {x:16.9, y:129.04, z:-8.16}, {x:23.5, y:116.08, z:-2.73}],
  [{x:13.88, y:0.0, z:12.01}, {x:16.37, y:3.4, z:9.94}, {x:21.87, y:0.0, z:9.52}],
  [{x:32.23, y:114.01, z:-4.06}, {x:29.4, y:117.63, z:-0.4}, {x:27.69, y:129.55, z:-5.45}],
  [{x:35.69, y:93.76, z:-0.06}, {x:31.92, y:94.01, z:1.43}, {x:29.4, y:117.63, z:-0.4}],
  [{x:35.69, y:93.76, z:-0.06}, {x:29.4, y:117.63, z:-0.4}, {x:32.23, y:114.01, z:-4.06}],
  [{x:13.88, y:0.0, z:12.01}, {x:21.87, y:0.0, z:9.52}, {x:19.47, y:0.0, z:-3.11}],
  [{x:21.87, y:0.0, z:9.52}, {x:16.37, y:3.4, z:9.94}, {x:19.42, y:4.3, z:0.32}],
  [{x:32.23, y:114.01, z:-4.06}, {x:27.69, y:129.55, z:-5.45}, {x:28.18, y:111.52, z:-9.83}],
  [{x:19.47, y:0.0, z:-3.11}, {x:21.87, y:0.0, z:9.52}, {x:19.42, y:4.3, z:0.32}],
  [{x:32.23, y:114.01, z:-4.06}, {x:28.18, y:111.52, z:-9.83}, {x:34.8, y:92.64, z:-3.71}],
  [{x:19.44, y:31.72, z:-8.19}, {x:14.87, y:10.9, z:-4.45}, {x:15.43, y:42.67, z:-2.11}],
  [{x:23.5, y:116.08, z:-2.73}, {x:31.92, y:94.01, z:1.43}, {x:31.73, y:92.65, z:-3.16}],
  [{x:13.33, y:12.02, z:-12.33}, {x:17.58, y:9.81, z:-9.1}, {x:17.93, y:32.42, z:-13.03}],
  [{x:23.5, y:116.08, z:-2.73}, {x:29.4, y:117.63, z:-0.4}, {x:31.92, y:94.01, z:1.43}],
  [{x:19.47, y:0.0, z:-3.11}, {x:19.42, y:4.3, z:0.32}, {x:17.58, y:9.81, z:-9.1}],
  [{x:19.47, y:0.0, z:-3.11}, {x:17.58, y:9.81, z:-9.1}, {x:16.44, y:0.0, z:-13.34}],
  [{x:19.44, y:31.72, z:-8.19}, {x:17.93, y:32.42, z:-13.03}, {x:17.58, y:9.81, z:-9.1}],
  [{x:14.87, y:10.9, z:-4.45}, {x:17.58, y:9.81, z:-9.1}, {x:19.42, y:4.3, z:0.32}],
  [{x:-20.34, y:140.73, z:-0.07}, {x:-18.73, y:147.28, z:-4.81}, {x:-6.8, y:137.5, z:8.41}],
  [{x:14.87, y:10.9, z:-4.45}, {x:19.44, y:31.72, z:-8.19}, {x:17.58, y:9.81, z:-9.1}],
  [{x:33.37, y:83.32, z:-2.28}, {x:31.73, y:92.65, z:-3.16}, {x:32.02, y:84.79, z:2.22}],
  [{x:-28.22, y:117.11, z:-2.22}, {x:-19.2, y:131.29, z:0.95}, {x:-24.05, y:116.19, z:-2.87}],
  [{x:33.37, y:83.32, z:-2.28}, {x:32.02, y:84.79, z:2.22}, {x:34.88, y:80.56, z:-1.02}],
  [{x:-24.79, y:138.1, z:-5.73}, {x:-20.34, y:140.73, z:-0.07}, {x:-19.2, y:131.29, z:0.95}],
  [{x:-12.81, y:131.21, z:8.0}, {x:-6.8, y:137.5, z:8.41}, {x:-3.08, y:110.12, z:10.2}],
  [{x:9.75, y:134.32, z:-16.79}, {x:-0.17, y:131.97, z:-15.23}, {x:8.86, y:112.13, z:-8.49}],
  [{x:3.33, y:147.61, z:-14.57}, {x:-0.17, y:131.97, z:-15.23}, {x:9.75, y:134.32, z:-16.79}],
  [{x:-6.8, y:137.5, z:8.41}, {x:-12.81, y:131.21, z:8.0}, {x:-20.34, y:140.73, z:-0.07}],
  [{x:-7.92, y:30.17, z:-10.24}, {x:-9.51, y:46.2, z:-11.28}, {x:-12.76, y:32.3, z:-15.34}],
  [{x:-8.24, y:42.01, z:-7.97}, {x:-9.51, y:46.2, z:-11.28}, {x:-7.92, y:30.17, z:-10.24}],
  [{x:-12.17, y:42.15, z:-1.95}, {x:-8.24, y:42.01, z:-7.97}, {x:-7.92, y:30.17, z:-10.24}],
  [{x:-14.98, y:11.23, z:-4.79}, {x:-19.42, y:31.72, z:-8.19}, {x:-15.41, y:42.67, z:-2.11}],
  [{x:8.86, y:112.13, z:-8.49}, {x:-0.17, y:131.97, z:-15.23}, {x:-9.07, y:133.45, z:-16.92}],
  [{x:-17.75, y:141.37, z:-11.91}, {x:-9.07, y:133.45, z:-16.92}, {x:3.33, y:147.61, z:-14.57}],
  [{x:-14.98, y:11.23, z:-4.79}, {x:-12.17, y:42.15, z:-1.95}, {x:-7.92, y:30.17, z:-10.24}],
  [{x:-0.17, y:131.97, z:-15.23}, {x:3.33, y:147.61, z:-14.57}, {x:-9.07, y:133.45, z:-16.92}],
  [{x:-11.42, y:15.46, z:-8.64}, {x:-14.98, y:11.23, z:-4.79}, {x:-7.92, y:30.17, z:-10.24}],
  [{x:-11.56, y:111.27, z:5.8}, {x:-12.81, y:131.21, z:8.0}, {x:-3.08, y:110.12, z:10.2}],
  [{x:-16.96, y:128.87, z:-8.25}, {x:-12.81, y:131.21, z:8.0}, {x:-11.56, y:111.27, z:5.8}],
  [{x:-19.2, y:131.29, z:0.95}, {x:-20.34, y:140.73, z:-0.07}, {x:-12.81, y:131.21, z:8.0}],
  [{x:-12.76, y:32.3, z:-15.34}, {x:-13.31, y:12.02, z:-12.33}, {x:-7.92, y:30.17, z:-10.24}],
  [{x:-7.92, y:30.17, z:-10.24}, {x:-13.31, y:12.02, z:-12.33}, {x:-11.42, y:15.46, z:-8.64}],
  [{x:-16.96, y:128.87, z:-8.25}, {x:-19.2, y:131.29, z:0.95}, {x:-12.81, y:131.21, z:8.0}],
  [{x:-13.31, y:12.02, z:-12.33}, {x:-12.76, y:32.3, z:-15.34}, {x:-17.91, y:32.42, z:-13.03}],
  [{x:-17.75, y:141.37, z:-11.91}, {x:-18.63, y:132.27, z:-11.45}, {x:-9.07, y:133.45, z:-16.92}],
  [{x:-9.07, y:133.45, z:-16.92}, {x:-18.63, y:132.27, z:-11.45}, {x:-13.01, y:123.05, z:-11.22}],
  [{x:-21.86, y:0.0, z:9.58}, {x:-19.45, y:0.0, z:-3.11}, {x:-19.26, y:5.4, z:0.36}],
  [{x:-13.78, y:4.9, z:3.64}, {x:-19.26, y:5.4, z:0.36}, {x:-14.98, y:11.23, z:-4.79}],
  [{x:-19.26, y:5.4, z:0.36}, {x:-13.78, y:4.9, z:3.64}, {x:-16.48, y:2.9, z:10.58}],
  [{x:-16.48, y:2.9, z:10.58}, {x:-21.86, y:0.0, z:9.58}, {x:-19.26, y:5.4, z:0.36}],
  [{x:-3.08, y:110.12, z:10.2}, {x:-6.8, y:137.5, z:8.41}, {x:3.51, y:131.96, z:10.76}],
  [{x:-19.45, y:0.0, z:-3.11}, {x:-21.86, y:0.0, z:9.58}, {x:-13.86, y:0.0, z:12.08}],
  [{x:5.62, y:159.98, z:-7.54}, {x:0.42, y:174.34, z:-12.68}, {x:-2.67, y:161.54, z:-10.64}],
  [{x:-19.42, y:31.72, z:-8.19}, {x:-14.98, y:11.23, z:-4.79}, {x:-17.57, y:9.81, z:-9.1}],
  [{x:-17.57, y:9.81, z:-9.1}, {x:-19.26, y:5.4, z:0.36}, {x:-19.45, y:0.0, z:-3.11}],
  [{x:-19.45, y:0.0, z:-3.11}, {x:-16.43, y:0.0, z:-13.34}, {x:-17.57, y:9.81, z:-9.1}],
  [{x:-13.31, y:12.02, z:-12.33}, {x:-17.57, y:9.81, z:-9.1}, {x:-16.43, y:0.0, z:-13.34}],
  [{x:-11.41, y:0.0, z:-11.73}, {x:-13.31, y:12.02, z:-12.33}, {x:-16.43, y:0.0, z:-13.34}],
  [{x:-17.91, y:32.42, z:-13.03}, {x:-19.42, y:31.72, z:-8.19}, {x:-17.57, y:9.81, z:-9.1}],
  [{x:-19.26, y:5.4, z:0.36}, {x:-17.57, y:9.81, z:-9.1}, {x:-14.98, y:11.23, z:-4.79}],
  [{x:-19.45, y:0.0, z:-3.11}, {x:-11.49, y:0.0, z:-3.66}, {x:-11.41, y:0.0, z:-11.73}],
  [{x:7.21, y:175.81, z:-7.69}, {x:5.62, y:159.98, z:-7.54}, {x:8.93, y:165.97, z:-3.32}],
  [{x:-16.43, y:0.0, z:-13.34}, {x:-19.45, y:0.0, z:-3.11}, {x:-11.41, y:0.0, z:-11.73}],
  [{x:0.42, y:174.34, z:-12.68}, {x:5.62, y:159.98, z:-7.54}, {x:7.21, y:175.81, z:-7.69}],
  [{x:-17.91, y:32.42, z:-13.03}, {x:-17.57, y:9.81, z:-9.1}, {x:-13.31, y:12.02, z:-12.33}],
  [{x:-14.98, y:11.23, z:-4.79}, {x:-11.49, y:0.0, z:-3.66}, {x:-13.78, y:4.9, z:3.64}],
  [{x:-11.49, y:0.0, z:-3.66}, {x:-13.86, y:0.0, z:12.08}, {x:-13.78, y:4.9, z:3.64}],
  [{x:-9.66, y:103.11, z:-9.98}, {x:-0.22, y:99.05, z:-11.54}, {x:9.68, y:103.12, z:-9.97}],
  [{x:-6.08, y:91.58, z:-14.06}, {x:-0.22, y:99.05, z:-11.54}, {x:-9.66, y:103.11, z:-9.98}],
  [{x:6.19, y:92.33, z:-13.85}, {x:-0.22, y:99.05, z:-11.54}, {x:-6.08, y:91.58, z:-14.06}],
  [{x:-6.08, y:91.58, z:-14.06}, {x:0.64, y:85.75, z:-12.63}, {x:6.19, y:92.33, z:-13.85}],
  [{x:8.86, y:112.13, z:-8.49}, {x:-8.69, y:111.57, z:-8.47}, {x:-9.66, y:103.11, z:-9.98}],
  [{x:7.21, y:175.81, z:-7.69}, {x:0.42, y:180.0, z:-2.63}, {x:0.42, y:174.34, z:-12.68}],
  [{x:-13.35, y:109.79, z:-2.09}, {x:-11.56, y:111.27, z:5.8}, {x:-18.52, y:73.06, z:1.33}],
  [{x:-5.79, y:165.74, z:5.99}, {x:0.69, y:168.11, z:9.89}, {x:0.55, y:156.87, z:8.06}],
  [{x:-13.08, y:95.32, z:6.43}, {x:-18.52, y:73.06, z:1.33}, {x:-11.56, y:111.27, z:5.8}],
  [{x:-9.66, y:103.11, z:-9.98}, {x:9.68, y:103.12, z:-9.97}, {x:8.86, y:112.13, z:-8.49}],
  [{x:0.42, y:180.0, z:-2.63}, {x:7.25, y:175.34, z:1.67}, {x:0.5, y:175.78, z:6.9}],
  [{x:-13.08, y:95.32, z:6.43}, {x:-11.56, y:111.27, z:5.8}, {x:-3.08, y:110.12, z:10.2}],
  [{x:-2.12, y:84.1, z:7.3}, {x:-13.08, y:95.32, z:6.43}, {x:-3.08, y:110.12, z:10.2}],
  [{x:-33.17, y:93.17, z:-3.78}, {x:-28.71, y:112.12, z:-9.14}, {x:-31.48, y:115.81, z:-5.59}],
  [{x:7.25, y:175.34, z:1.67}, {x:6.75, y:166.1, z:5.26}, {x:0.69, y:168.11, z:9.89}],
  [{x:-30.16, y:93.04, z:-2.95}, {x:-33.17, y:93.17, z:-3.78}, {x:-33.07, y:82.17, z:-3.4}],
  [{x:-33.17, y:93.17, z:-3.78}, {x:-30.16, y:93.04, z:-2.95}, {x:-28.71, y:112.12, z:-9.14}],
  [{x:8.93, y:165.97, z:-3.32}, {x:6.75, y:166.1, z:5.26}, {x:7.25, y:175.34, z:1.67}],
  [{x:-24.52, y:112.16, z:-7.62}, {x:-16.96, y:128.87, z:-8.25}, {x:-28.71, y:112.12, z:-9.14}],
  [{x:7.21, y:175.81, z:-7.69}, {x:8.93, y:165.97, z:-3.32}, {x:7.25, y:175.34, z:1.67}],
  [{x:-33.17, y:93.17, z:-3.78}, {x:-34.65, y:93.99, z:-0.57}, {x:-33.07, y:82.17, z:-3.4}],
  [{x:-31.48, y:115.81, z:-5.59}, {x:-28.22, y:117.11, z:-2.22}, {x:-34.65, y:93.99, z:-0.57}],
  [{x:-6.7, y:175.25, z:3.19}, {x:0.42, y:180.0, z:-2.63}, {x:0.5, y:175.78, z:6.9}],
  [{x:7.21, y:175.81, z:-7.69}, {x:7.25, y:175.34, z:1.67}, {x:0.42, y:180.0, z:-2.63}],
  [{x:5.62, y:159.98, z:-7.54}, {x:-2.67, y:161.54, z:-10.64}, {x:5.69, y:152.95, z:-8.75}],
  [{x:-2.67, y:161.54, z:-10.64}, {x:-3.02, y:154.6, z:-10.54}, {x:5.69, y:152.95, z:-8.75}],
  [{x:3.33, y:147.61, z:-14.57}, {x:5.69, y:152.95, z:-8.75}, {x:-3.02, y:154.6, z:-10.54}],
  [{x:-30.73, y:94.21, z:1.66}, {x:-34.39, y:88.52, z:3.92}, {x:-34.65, y:93.99, z:-0.57}],
  [{x:-30.73, y:94.21, z:1.66}, {x:-30.61, y:90.14, z:3.83}, {x:-34.39, y:88.52, z:3.92}],
  [{x:20.74, y:143.49, z:-8.79}, {x:20.0, y:147.35, z:-4.74}, {x:3.33, y:147.61, z:-14.57}],
  [{x:-30.73, y:94.21, z:1.66}, {x:-34.65, y:93.99, z:-0.57}, {x:-28.22, y:117.11, z:-2.22}],
  [{x:3.33, y:147.61, z:-14.57}, {x:20.0, y:147.35, z:-4.74}, {x:5.69, y:152.95, z:-8.75}],
  [{x:-31.09, y:84.88, z:4.73}, {x:-30.16, y:93.04, z:-2.95}, {x:-33.07, y:82.17, z:-3.4}],
  [{x:9.75, y:134.32, z:-16.79}, {x:20.74, y:143.49, z:-8.79}, {x:3.33, y:147.61, z:-14.57}],
  [{x:-24.05, y:116.19, z:-2.87}, {x:-30.73, y:94.21, z:1.66}, {x:-28.22, y:117.11, z:-2.22}],
  [{x:-33.17, y:93.17, z:-3.78}, {x:-31.48, y:115.81, z:-5.59}, {x:-34.65, y:93.99, z:-0.57}],
  [{x:-24.05, y:116.19, z:-2.87}, {x:-16.96, y:128.87, z:-8.25}, {x:-24.52, y:112.16, z:-7.62}],
  [{x:-24.52, y:112.16, z:-7.62}, {x:-30.73, y:94.21, z:1.66}, {x:-24.05, y:116.19, z:-2.87}],
  [{x:-6.8, y:137.5, z:8.41}, {x:4.07, y:147.56, z:0.76}, {x:3.51, y:131.96, z:10.76}],
  [{x:0.69, y:168.11, z:9.89}, {x:6.75, y:166.1, z:5.26}, {x:0.55, y:156.87, z:8.06}],
  [{x:4.07, y:147.56, z:0.76}, {x:-2.54, y:148.17, z:0.54}, {x:4.28, y:155.17, z:2.21}],
  [{x:-34.39, y:88.52, z:3.92}, {x:-35.44, y:84.25, z:4.9}, {x:-34.65, y:93.99, z:-0.57}],
  [{x:-3.45, y:154.98, z:2.21}, {x:4.28, y:155.17, z:2.21}, {x:-2.54, y:148.17, z:0.54}],
  [{x:-34.65, y:93.99, z:-0.57}, {x:-35.44, y:84.25, z:4.9}, {x:-35.93, y:82.79, z:-1.1}],
  [{x:6.75, y:166.1, z:5.26}, {x:4.28, y:155.17, z:2.21}, {x:0.55, y:156.87, z:8.06}],
  [{x:8.93, y:165.97, z:-3.32}, {x:4.28, y:155.17, z:2.21}, {x:6.75, y:166.1, z:5.26}],
  [{x:5.62, y:159.98, z:-7.54}, {x:4.28, y:155.17, z:2.21}, {x:8.93, y:165.97, z:-3.32}],
  [{x:9.95, y:139.4, z:6.21}, {x:4.07, y:147.56, z:0.76}, {x:20.0, y:147.35, z:-4.74}],
  [{x:20.0, y:147.35, z:-4.74}, {x:4.07, y:147.56, z:0.76}, {x:5.69, y:152.95, z:-8.75}],
  [{x:5.69, y:152.95, z:-8.75}, {x:4.07, y:147.56, z:0.76}, {x:5.62, y:159.98, z:-7.54}],
  [{x:-33.14, y:80.76, z:5.6}, {x:-34.39, y:88.52, z:3.92}, {x:-31.09, y:84.88, z:4.73}],
  [{x:4.28, y:155.17, z:2.21}, {x:5.62, y:159.98, z:-7.54}, {x:4.07, y:147.56, z:0.76}],
  [{x:9.95, y:139.4, z:6.21}, {x:20.0, y:147.35, z:-4.74}, {x:18.57, y:140.73, z:-0.07}],
  [{x:-34.39, y:88.52, z:3.92}, {x:-30.61, y:90.14, z:3.83}, {x:-31.09, y:84.88, z:4.73}],
  [{x:27.69, y:129.55, z:-5.45}, {x:18.57, y:140.73, z:-0.07}, {x:20.0, y:147.35, z:-4.74}],
  [{x:20.74, y:143.49, z:-8.79}, {x:27.69, y:129.55, z:-5.45}, {x:20.0, y:147.35, z:-4.74}],
  [{x:-33.07, y:82.17, z:-3.4}, {x:-35.93, y:82.79, z:-1.1}, {x:-33.11, y:80.02, z:-2.17}],
  [{x:-34.65, y:93.99, z:-0.57}, {x:-35.93, y:82.79, z:-1.1}, {x:-33.07, y:82.17, z:-3.4}],
  [{x:-33.63, y:79.68, z:1.3}, {x:-31.09, y:84.88, z:4.73}, {x:-33.11, y:80.02, z:-2.17}],
  [{x:-33.11, y:80.02, z:-2.17}, {x:-31.09, y:84.88, z:4.73}, {x:-33.07, y:82.17, z:-3.4}],
  [{x:-35.93, y:82.79, z:-1.1}, {x:-35.44, y:84.25, z:4.9}, {x:-33.14, y:80.76, z:5.6}],
  [{x:-35.44, y:84.25, z:4.9}, {x:-34.39, y:88.52, z:3.92}, {x:-33.14, y:80.76, z:5.6}],
  [{x:-33.14, y:80.76, z:5.6}, {x:-31.09, y:84.88, z:4.73}, {x:-33.63, y:79.68, z:1.3}],
  [{x:-33.14, y:80.76, z:5.6}, {x:-33.63, y:79.68, z:1.3}, {x:-35.93, y:82.79, z:-1.1}],
  [{x:-30.61, y:90.14, z:3.83}, {x:-30.73, y:94.21, z:1.66}, {x:-30.16, y:93.04, z:-2.95}],
  [{x:-33.63, y:79.68, z:1.3}, {x:-33.11, y:80.02, z:-2.17}, {x:-35.93, y:82.79, z:-1.1}],
  [{x:-30.16, y:93.04, z:-2.95}, {x:-31.09, y:84.88, z:4.73}, {x:-30.61, y:90.14, z:3.83}],
  [{x:31.73, y:92.65, z:-3.16}, {x:31.92, y:94.01, z:1.43}, {x:32.02, y:84.79, z:2.22}],
  [{x:36.91, y:82.3, z:-0.36}, {x:34.88, y:80.56, z:-1.02}, {x:35.24, y:79.42, z:1.54}],
  [{x:35.24, y:79.42, z:1.54}, {x:37.07, y:80.69, z:4.7}, {x:36.91, y:82.3, z:-0.36}],
  [{x:-30.16, y:93.04, z:-2.95}, {x:-30.73, y:94.21, z:1.66}, {x:-24.52, y:112.16, z:-7.62}],
  [{x:-28.71, y:112.12, z:-9.14}, {x:-30.16, y:93.04, z:-2.95}, {x:-24.52, y:112.16, z:-7.62}],
  [{x:-6.7, y:175.25, z:3.19}, {x:0.5, y:175.78, z:6.9}, {x:0.69, y:168.11, z:9.89}],
  [{x:-6.7, y:175.25, z:3.19}, {x:0.69, y:168.11, z:9.89}, {x:-5.79, y:165.74, z:5.99}],
];

  function drawTargets3D() {
    if (viewDim !== '3d') return;
    if (!HUMAN_TRIANGLES.length) return;
    const live = livePosFor(selectedDevice?.device_id);

    const faces = [];
    const color = WALL_COLOR;
    const SCALE = 1;

    function pushFace(verts) {
      const proj = verts.map(v => project3D(v.x, v.y, v.z));
      if (proj.some(p => !p)) return;
      const depth = proj.reduce((s, p) => s + p.z, 0) / proj.length;
      faces.push({ proj, depth });
    }

    for (const n of [1, 2, 3, 4, 5]) {
      const p = live[n];
      if (!p || !Number.isFinite(p.x) || !Number.isFinite(p.y)) continue;
      if (p.x === 0 && p.y === 0) continue;

      const wx = clampBaseX(p.x);
      const wz = clampBaseY(p.y);

      const angleRad = Number.isFinite(p.heading) ? p.heading : 0;
      const cosA = Math.cos(angleRad);
      const sinA = Math.sin(angleRad);

      for (const tri of HUMAN_TRIANGLES) {
        const v0 = tri[0];
        const v1 = tri[1];
        const v2 = tri[2];

        function transform(v) {
          const lx = v.x * SCALE;
          const ly = v.y * SCALE;
          const lz = v.z * SCALE;

          const rx = lx * cosA + lz * sinA;
          const rz = -lx * sinA + lz * cosA;

          return {
            x: wx + rx,
            y: ly,
            z: wz + rz
          };
        }

        const verts = [transform(v0), transform(v1), transform(v2)];
        pushFace(verts);
      }
    }

    faces.sort((a, b) => b.depth - a.depth);

    ctx.save();
    ctx.strokeStyle = color;
    ctx.fillStyle   = color;

    for (const f of faces) {
      ctx.beginPath();
      ctx.moveTo(f.proj[0].x, f.proj[0].y);
      for (let i = 1; i < f.proj.length; i++) {
        ctx.lineTo(f.proj[i].x, f.proj[i].y);
      }
      ctx.closePath();

      ctx.globalAlpha = 0.20;
      ctx.fill();

      ctx.globalAlpha = 0.4;
      ctx.lineWidth   = 0.25;
      ctx.stroke();
    }

    ctx.restore();
  }

  function drawFloorplan3D(){
    ctx.save();
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.globalCompositeOperation = 'source-over';
    ctx.globalAlpha = 1;
    ctx.fillStyle = '#0a0d12';
    ctx.fillRect(0, 0, cvs.width / dpr, cvs.height / dpr);
    ctx.restore();

    updateCamera3D(FLOORPLAN_BOUNDS);
    if(shouldShowFloorplanGrid()) drawGrid3D(FLOORPLAN_BOUNDS, GRID);
    drawFloorplanWalls3D();
    drawFloorplanSensorOverlay3D();
  }

  function drawScene3D(){
    ctx.save();
ctx.setTransform(dpr,0,0,dpr,0,0);
ctx.globalCompositeOperation = 'source-over';
ctx.globalAlpha = 1;
ctx.fillStyle = '#0a0d12';
ctx.fillRect(0, 0, cvs.width / dpr, cvs.height / dpr);
ctx.restore();

    updateCamera3D();
    const maxR = fovMaxRange();
    drawFov3D(maxR,false);
    if(detRange>0 && detRange<maxR){
      drawFov3D(detRange,true);
    }
    if(viewMode === 'heatmap'){
      drawHeatmap3D();
    }
    drawFovGuides3D();
    drawZones3D();
    drawTargets3D();
  }

  let drawQueued=false;
  function enqueueDraw(){
    if(drawQueued) return;
    if(!floorplanEnabled) syncActiveSensorState();
    drawQueued=true;
    requestAnimationFrame(()=>{ drawQueued=false; draw(); });
  }

  function draw(){
    ctx.save();
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.globalCompositeOperation = 'source-over';
    ctx.globalAlpha = 1;
    ctx.fillStyle = '#0a0d12';
    ctx.fillRect(0, 0, cvs.width / dpr, cvs.height / dpr);
    ctx.restore();


    if(floorplanEnabled){
      if(viewDim === '3d') drawFloorplan3D();
      else drawFloorplan2DView();
    } else if(viewDim === '3d'){
      drawScene3D();
    } else {
      const maxR = fovMaxRange();
      drawFov(maxR,false);
      if(detRange>0&&detRange<maxR) drawFov(detRange,true);
      if(viewMode === 'heatmap'){
        drawHeatmap2D();
      }
      drawFovGuides2D();
      for(const key of ['1','2','3','excl']){
        const active = currentZone && key===currentZone;
        const style=zoneStyle(key,active);
        if(!active) drawPolygon(zones[key],style);
      }
      if(currentZone && zones[currentZone]){
        drawPolygon(zones[currentZone],zoneStyle(currentZone,true));
        drawHandles(zones[currentZone]);
      }
      drawTargets();
    }

    const showLegend = (!floorplanEnabled && viewMode === 'heatmap');
    legend.style.display = showLegend ? 'flex' : 'none';
    if(floorplanTools){
      const showTools = floorplanEnabled && viewDim === '2d' && !IS_MOBILE;
      floorplanTools.style.display = showTools ? 'flex' : 'none';
    }
    if(floorplanHistoryBar){
      const showHistory = floorplanEnabled && viewDim === '2d' && !IS_MOBILE;
      floorplanHistoryBar.style.display = showHistory ? 'flex' : 'none';
    }
    if(viewToggle){
      viewToggle.style.display = 'flex';
    }
    if(floorplanBtn){
      floorplanBtn.classList.toggle('active',floorplanEnabled);
      floorplanBtn.setAttribute('aria-pressed', floorplanEnabled ? 'true' : 'false');
    }

    viewToggleBtns.forEach(btn=>{
      const v = btn.dataset.view;
      const active = (v === viewDim);
      btn.classList.toggle('active',active);
    });
  }

  let dragIdx=null, dragWhole=false, lastPX=0, lastPY=0;
  const pointerPos={x:0,y:0};

  function localPoint(clientX,clientY,out=pointerPos){
    const r=cvs.getBoundingClientRect();
    const sx=(cvs.width/dpr)/r.width, sy=(cvs.height/dpr)/r.height;
    out.x=(clientX-r.left)*sx;
    out.y=(clientY-r.top)*sy;
    return out;
  }

  function nearestIdx(px,py){
    if(!currentZone) return -1;
    const pts=zones[currentZone];
    if(!pts) return -1;
    let best=-1,dmin=14;
    for(let i=0;i<pts.length;i++){
      const dx=toPxX(pts[i].x)-px, dy=toPxY(pts[i].y)-py;
      const d=Math.hypot(dx,dy);
      if(d<dmin){ dmin=d; best=i; }
    }
    return best;
  }

  function distToSegment(px,py,ax,ay,bx,by){
    const vx=bx-ax, vy=by-ay;
    const wx=px-ax, wy=py-ay;
    const c1=vx*wx+vy*wy;
    if(c1<=0) return Math.hypot(px-ax,py-ay);
    const c2=vx*vx+vy*vy;
    if(c2<=c1) return Math.hypot(px-bx,py-by);
    const t=c1/c2;
    const projx=ax+t*vx, projy=ay+t*vy;
    return Math.hypot(px-projx,py-projy);
  }

  function nearestEdge(px,py){
    if(!currentZone) return {idx:-1,dist:Infinity};
    const pts=zones[currentZone];
    if(!pts || pts.length<2) return {idx:-1,dist:Infinity};

    let bestIdx=-1;
    let dmin=10;

    for(let i=0;i<pts.length;i++){
      const j=(i+1)%pts.length;

      const ax=toPxX(pts[i].x), ay=toPxY(pts[i].y);
      const bx=toPxX(pts[j].x), by=toPxY(pts[j].y);
      const d=distToSegment(px,py,ax,ay,bx,by);
      if(d<dmin){
        dmin=d;
        bestIdx=i;
      }
    }
    return {idx:bestIdx,dist:dmin};
  }

  function pointInPoly(pts,px,py){
    if(!pts||pts.length<3) return false;
    const x=toCmX(px), y=toCmY(py);
    let inside=false;
    for(let i=0,j=pts.length-1;i<pts.length;j=i++){
      const xi=pts[i].x, yi=pts[i].y, xj=pts[j].x, yj=pts[j].y;
      const intersect=((yi>y)!==(yj>y))&&(x< (xj-xi)*(y-yi)/(yj-yi+1e-9)+xi);
      if(intersect) inside=!inside;
    }
    return inside;
  }
  function hitZoneAt(px,py){
    const order=[currentZone,'1','2','3','excl'].filter((v,i,self)=>self.indexOf(v)===i);
    for(const z of order){
      const pts=zones[z];
      if(pointInPoly(pts,px,py)) return z;
    }
    return null;
  }

  const FLOORPLAN_SNAP_PX = 14;
  const FLOORPLAN_SENSOR_SNAP_PX = 12;
  const FLOORPLAN_HEIGHT_SNAP_PX = 10;
  const FLOORPLAN_WIDTH_SNAP_PX = 10;

  function floorplanWorldPointFromPx(px,py){
    return {
      x:clamp(fpFromPxX(px),FLOORPLAN_BOUNDS.xMin,FLOORPLAN_BOUNDS.xMax),
      y:clamp(fpFromPxY(py),FLOORPLAN_BOUNDS.yMin,FLOORPLAN_BOUNDS.yMax)
    };
  }

  function floorplanLocalFromPx(px,py,sensor){
    const world=floorplanWorldPointFromPx(px,py);
    return sensorWorldToLocal(world, sensor);
  }

  function floorplanNearestIdx(px,py,sensor){
    if(!currentZone || !sensor) return -1;
    const pts=zones[currentZone];
    if(!pts) return -1;
    let best=-1,dmin=14;
    for(let i=0;i<pts.length;i++){
      const w=sensorLocalToWorld(pts[i], sensor);
      const dx=fpToPxX(w.x)-px;
      const dy=fpToPxY(w.y)-py;
      const d=Math.hypot(dx,dy);
      if(d<dmin){
        dmin=d;
        best=i;
      }
    }
    return best;
  }

  function floorplanNearestEdge(px,py,sensor){
    if(!currentZone || !sensor) return {idx:-1,dist:Infinity};
    const pts=zones[currentZone];
    if(!pts || pts.length<2) return {idx:-1,dist:Infinity};
    let bestIdx=-1;
    let dmin=10;
    for(let i=0;i<pts.length;i++){
      const j=(i+1)%pts.length;
      const a=sensorLocalToWorld(pts[i], sensor);
      const b=sensorLocalToWorld(pts[j], sensor);
      const ax=fpToPxX(a.x), ay=fpToPxY(a.y);
      const bx=fpToPxX(b.x), by=fpToPxY(b.y);
      const d=distToSegment(px,py,ax,ay,bx,by);
      if(d<dmin){
        dmin=d;
        bestIdx=i;
      }
    }
    return {idx:bestIdx,dist:dmin};
  }

  function floorplanPointInPoly(pts,px,py,sensor){
    if(!pts||pts.length<3||!sensor) return false;
    const world=floorplanWorldPointFromPx(px,py);
    const p=sensorWorldToLocal(world, sensor);
    let inside=false;
    for(let i=0,j=pts.length-1;i<pts.length;j=i++){
      const xi=pts[i].x, yi=pts[i].y, xj=pts[j].x, yj=pts[j].y;
      const intersect=((yi>p.y)!==(yj>p.y))&&(p.x< (xj-xi)*(p.y-yi)/(yj-yi+1e-9)+xi);
      if(intersect) inside=!inside;
    }
    return inside;
  }

  function floorplanHitZoneAt(px,py,sensor){
    const order=[currentZone,'1','2','3','excl'].filter((v,i,self)=>self.indexOf(v)===i);
    for(const z of order){
      const pts=zones[z];
      if(floorplanPointInPoly(pts,px,py,sensor)) return z;
    }
    return null;
  }

  function closestPointOnSegmentPx(px,py,ax,ay,bx,by){
    const vx=bx-ax, vy=by-ay;
    const wx=px-ax, wy=py-ay;
    const c2=vx*vx+vy*vy;
    if(c2<=1e-6){
      const dist=Math.hypot(px-ax,py-ay);
      return {px:ax,py:ay,dist};
    }
    const t=clamp((wx*vx+wy*vy)/c2,0,1);
    const projx=ax+t*vx, projy=ay+t*vy;
    return {px:projx,py:projy,dist:Math.hypot(px-projx,py-projy)};
  }

  function snapToFloorplan(px,py){
    let best=null;
    const consider=(x,y,dist,type)=>{
      if(dist>FLOORPLAN_SNAP_PX) return;
      if(!best || dist<best.dist){
        best={x,y,dist,type};
      }
    };

    for(const line of floorplanPolylines){
      if(!line) continue;
      for(const p of line){
        const dist=Math.hypot(fpToPxX(p.x)-px, fpToPxY(p.y)-py);
        consider(p.x,p.y,dist,'vertex');
      }
    }

    for(const line of floorplanPolylines){
      if(!line || line.length<2) continue;
      for(let i=0;i<line.length-1;i++){
        const a=line[i], b=line[i+1];
        const proj=closestPointOnSegmentPx(px,py, fpToPxX(a.x),fpToPxY(a.y), fpToPxX(b.x),fpToPxY(b.y));
        consider(fpFromPxX(proj.px), fpFromPxY(proj.py), proj.dist,'edge');
      }
    }
    return best;
  }

  function applyHeightSnap(world, px, py){
    let bestY=null, bestDist=FLOORPLAN_HEIGHT_SNAP_PX;
    for(const line of floorplanPolylines){
      if(!line) continue;
      for(const p of line){
        const dyPx=Math.abs(fpToPxY(p.y)-py);
        if(dyPx<=bestDist){
          bestDist=dyPx;
          bestY=p.y;
        }
      }
    }
    if(bestY!==null){
      return {world:{x:world.x,y:bestY}, snapLineY:bestY};
    }
    return {world, snapLineY:null};
  }

  function applyWidthSnap(world, px, py){
    let bestX=null, bestDist=FLOORPLAN_WIDTH_SNAP_PX;
    for(const line of floorplanPolylines){
      if(!line) continue;
      for(const p of line){
        const dxPx=Math.abs(fpToPxX(p.x)-px);
        if(dxPx<=bestDist){
          bestDist=dxPx;
          bestX=p.x;
        }
      }
    }
    if(bestX!==null){
      return {world:{x:bestX,y:world.y}, snapLineX:bestX};
    }
    return {world, snapLineX:null};
  }

  function floorplanFindVertex(px,py){
    let best={line:-1,idx:-1,dist:Infinity};
    for(let li=0;li<floorplanPolylines.length;li++){
      const line=floorplanPolylines[li];
      if(!line) continue;
      for(let pi=0;pi<line.length;pi++){
        const d=Math.hypot(fpToPxX(line[pi].x)-px, fpToPxY(line[pi].y)-py);
        if(d<best.dist){
          best={line:li,idx:pi,dist:d};
        }
      }
    }
    return best;
  }

  function applyAxisSnap(world,lastWorld,_shiftKey){
    return world;
  }

  function sensorWorldFromPx(px,py){
    const snap = snapToFloorplan(px,py);
    if(snap) return {world:{x:snap.x,y:snap.y}, snapped:true};
    return {world:floorplanWorldPointFromPx(px,py), snapped:false};
  }

  function handleFloorplanSelectDown(px,py,shiftKey=false, button=0){
    const snapRes=sensorWorldFromPx(px,py);
    const world=snapRes.world;

    const rotHit = sensorRotateHit(px,py);
    if(button===0 && rotHit.hitIdx>=0){
      pushFloorplanHistory();
      floorplanSensorRotating=rotHit.hitIdx;
      floorplanDragMode='rotate';
      floorplanSensors[rotHit.hitIdx].angle=rotHit.angle;
      const h=sensorHandleWorld(floorplanSensors[rotHit.hitIdx]);
      floorplanSensorHover = h ? {x:h.x,y:h.y} : null;
      selectSensorContext(floorplanSensors[rotHit.hitIdx]);
      enqueueDraw();
      return;
    }
    const hitIdx = sensorAtPx(px,py);
    if(button===0 && hitIdx>=0){
      pushFloorplanHistory();
      floorplanSensorDragging=hitIdx;
      floorplanSensorHover=null;
      selectSensorContext(floorplanSensors[hitIdx]);
      enqueueDraw();
      return;
    }

    if(floorplanTool==='sensor'){
      if(button===2 && hitIdx>=0){
        pushFloorplanHistory();
        floorplanSensors.splice(hitIdx,1);
        enqueueDraw();
        return;
      }
      if(button===0){
        const dev = placementDevice();
        if(!dev){
          reportError('Sensor placement failed');
          return;
        }
        pushFloorplanHistory();
        const existingIdx = floorplanSensors.findIndex(s=>s.device_id===dev.device_id);
        const newSensor = clampSensorPos(makeSensor(world.x,world.y,dev));
        if(existingIdx>=0){
          floorplanSensors[existingIdx]=newSensor;
        }else{
          floorplanSensors.push(newSensor);
        }
        floorplanSensorHover=null;
        setReady();
        enqueueDraw();
        return;
      }
    }

  }

  function handleFloorplanZoneDown(px,py,shiftKey=false,button=0){
    const sensor = activeFloorplanSensor();
    if(!sensor){
      reportError('Zone is not valid');
      return;
    }
    if(!zones[currentZone]) zones[currentZone]=[];
    const pts = zones[currentZone];
    floorplanZoneLastPX=px;
    floorplanZoneLastPY=py;

    if(button===2){
      const idx=floorplanNearestIdx(px,py,sensor);
      if(idx>=0){
        pushFloorplanHistory();
        pts.splice(idx,1);
        floorplanZoneDragIdx=null;
        floorplanZoneDragWhole=false;
        syncActiveFloorplanSensorZones();
        enqueueDraw();
      }
      return;
    }

    const idx=floorplanNearestIdx(px,py,sensor);
    if(idx>=0){
      floorplanZoneDragIdx=idx;
      pushFloorplanHistory();
      enqueueDraw();
      return;
    }

    if(pts.length>=2 && pts.length<MAX_POINTS){
      const edge=floorplanNearestEdge(px,py,sensor);
      if(edge.idx>=0){
        const local=floorplanLocalFromPx(px,py,sensor);
        const p={
          x:Math.round(local.x),
          y:Math.round(local.y)
        };
        const insertAt=edge.idx+1;
        pushFloorplanHistory();
        pts.splice(insertAt,0,p);
        floorplanZoneDragIdx=insertAt;
        syncActiveFloorplanSensorZones();
        enqueueDraw();
        return;
      }
    }

    const hit=floorplanHitZoneAt(px,py,sensor);
    if(hit){
      if(hit!==currentZone){
        setCurrentZone(hit);
      }
      floorplanZoneDragWhole=true;
      floorplanZoneDragIdx=null;
      return;
    }

    if(pts.length>=MAX_POINTS) return;
    const local=floorplanLocalFromPx(px,py,sensor);
    const wasEmpty = pts.length === 0;
    pts.push({
      x:Math.round(local.x),
      y:Math.round(local.y)
    });
    pushFloorplanHistory();
    syncActiveFloorplanSensorZones();
    if(wasEmpty) setReady();
    enqueueDraw();
  }

  function handleFloorplanSelectMove(px,py){
    const snapRes=sensorWorldFromPx(px,py);
    const world=snapRes.world;

    if(floorplanSensorRotating!==null){
      const s=floorplanSensors[floorplanSensorRotating];
      if(s){
        const dx = world.x - s.x;
        const dy = world.y - s.y;
        s.angle = Math.atan2(-dx, dy);
        const h = sensorHandleWorld(s);
        floorplanSensorHover = h ? {x:h.x,y:h.y} : null;
      }
      enqueueDraw();
      return;
    }

    if(floorplanSensorDragging!==null && floorplanSensors[floorplanSensorDragging]){
      floorplanSensors[floorplanSensorDragging].x=world.x;
      floorplanSensors[floorplanSensorDragging].y=world.y;
      floorplanSensorHover=null;
      selectSensorContext(floorplanSensors[floorplanSensorDragging]);
      enqueueDraw();
      return;
    }

    if(floorplanTool==='sensor'){
      const devId = placementDevice()?.device_id;
      const hasSensor = devId && floorplanSensors.some(s=>s.device_id===devId);
      floorplanSensorHover = hasSensor ? null : world;
      enqueueDraw();
    }
  }

  function handleFloorplanZoneMove(px,py){
    const sensor=activeFloorplanSensor();
    if(!sensor || !currentZone) return;
    const pts=zones[currentZone];
    if(!pts) return;

    if(floorplanZoneDragWhole){
      const curr=floorplanLocalFromPx(px,py,sensor);
      const prev=floorplanLocalFromPx(floorplanZoneLastPX,floorplanZoneLastPY,sensor);
      const dx=curr.x - prev.x;
      const dy=curr.y - prev.y;
      const next=pts.map(p=>({x:p.x+dx, y:p.y+dy}));
      for(let i=0;i<pts.length;i++){
        pts[i]=next[i];
      }
      floorplanZoneLastPX=px;
      floorplanZoneLastPY=py;
      syncActiveFloorplanSensorZones();
      enqueueDraw();
      return;
    }

    if(floorplanZoneDragIdx!=null){
      const local=floorplanLocalFromPx(px,py,sensor);
      pts[floorplanZoneDragIdx]={
        x:Math.round(local.x),
        y:Math.round(local.y)
      };
      syncActiveFloorplanSensorZones();
      enqueueDraw();
    }
  }

  function finishFloorplanInteraction(){
    if(floorplanSensorRotating!==null){
      floorplanSensorRotating=null;
    }
    if(floorplanSensorDragging!==null){
      floorplanSensorDragging=null;
    }
    if(floorplanZoneDragIdx!==null || floorplanZoneDragWhole){
      syncActiveFloorplanSensorZones();
    }
    floorplanZoneDragIdx=null;
    floorplanZoneDragWhole=false;
    floorplanDragMode=null;
    floorplanSensorHover=null;
    applyFloorplanAutoFitIfDirty();
    enqueueDraw();
  }

  function normalizePolyline(arr){
    if(!Array.isArray(arr)) return [];
    return arr.map(p=>({
      x:clamp(Number(p.x)||0,FLOORPLAN_BOUNDS.xMin,FLOORPLAN_BOUNDS.xMax),
      y:clamp(Number(p.y)||0,FLOORPLAN_BOUNDS.yMin,FLOORPLAN_BOUNDS.yMax)
    })).filter(p=>Number.isFinite(p.x)&&Number.isFinite(p.y));
  }

  function snapshotFloorplan(){
    return {
      polylines: floorplanPolylines.map(l=>l.map(p=>({...p}))),
      sensors: floorplanSensors.map(s=>({
        ...s,
        zones: cloneZones(s.zones||zones)
      }))
    };
  }

  function restoreFloorplan(state){
    floorplanPolylines = (state?.polylines||[]).map(normalizePolyline).filter(l=>l.length);
    floorplanSensors = (state?.sensors||[]).map(clampSensorPos);
  }

  function pushFloorplanHistory(){
    floorplanHistory.push(snapshotFloorplan());
    if(floorplanHistory.length>50) floorplanHistory.shift();
    floorplanFuture=[];
  }

  function undoFloorplan(){
    if(!floorplanHistory.length){
      return;
    }
    const current=snapshotFloorplan();
    const prev=floorplanHistory.pop();
    floorplanFuture.push(current);
    restoreFloorplan(prev);
    applyFloorplanAutoFit();
    setReady();
    const active = activeFloorplanSensor();
    if(active) adoptZonesFromSensor(active);
    else enqueueDraw();
  }

  function redoFloorplan(){
    if(!floorplanFuture.length){
      return;
    }
    const current=snapshotFloorplan();
    const next=floorplanFuture.pop();
    floorplanHistory.push(current);
    restoreFloorplan(next);
    applyFloorplanAutoFit();
    setReady();
    const active = activeFloorplanSensor();
    if(active) adoptZonesFromSensor(active);
    else enqueueDraw();
  }

  function resetFloorplanSelectionAndModes(){
    clearZoneSelection();
    setFloorplanTool('view');
    floorplanActiveLine=null;
    floorplanPreview=null;
    floorplanPreviewSuppressed=false;
    floorplanLengthInput='';
    floorplanDragMode=null;
    floorplanSensorHover=null;
    floorplanSensorDragging=null;
    floorplanSensorRotating=null;
    floorplanZoneDragIdx=null;
    floorplanZoneDragWhole=false;
    floorplanZoneLastPX=0;
    floorplanZoneLastPY=0;
  }

  function readNumberBySuffixFrom(list, suffix){
    const e=list?.find(x=>x.entity_id?.endsWith(suffix));
    if(!e) return null;
    const v=(typeof e.state==='number')?e.state:Number(e.state);
    return Number.isFinite(v)?v:null;
  }

  function detectInstallModeFromEntities(list){
    const match=list?.find(x=>x.entity_id?.includes('radar_installation_method'));
    const state=(match?.state ?? '').toString().trim().toLowerCase();
    return normalizeInstallModeValue(state);
  }

  function zonesFromEntities(list){
    let hasData=false;
    const next={'1':[],'2':[],'3':[],'excl':[]};
    for(const z of ['1','2','3','excl']){
      const id=zid(z);
      const rawCount=readNumberBySuffixFrom(list,id.count);
      if(rawCount!==null) hasData=true;
      const n=Math.max(0,Math.min(MAX_POINTS,Math.round(rawCount||0)));
      const pts=[];
      for(let i=1;i<=n;i++){
        const x=readNumberBySuffixFrom(list,id.x(i));
        const y=readNumberBySuffixFrom(list,id.y(i));
        pts.push({
          x: Number.isFinite(x) ? x : 0,
          y: Number.isFinite(y) ? y : 0
        });
      }
      next[z]=pts;
    }
    return {zones: next, hasData};
  }

  async function refreshAllFloorplanSensorsFromHA(){
    if(!floorplanSensors.length) return;
    const sensorById=new Map();
    floorplanSensors.forEach(s=>{
      if(s?.device_id && !sensorById.has(s.device_id)) sensorById.set(s.device_id, s);
    });
    const ids=[...sensorById.keys()];
    if(!ids.length) return;
    const results=await Promise.allSettled(
      ids.map(deviceId=>api('api/device_entities',{device_id:deviceId},{reloadOnError:false}))
    );
    const updates=new Map();
    results.forEach((res, idx)=>{
      if(res.status!=='fulfilled') return;
      const deviceId=ids[idx];
      let arr=[];
      try{
        arr=Array.isArray(res.value)?res.value:JSON.parse(res.value||'[]');
      }catch(_e){
        return;
      }
      const list=arr.map(e=>({entity_id:e.entity_id,domain:e.domain,state:e.state,attributes:e.attributes||{}}));
      const existing=sensorById.get(deviceId);
      const fallbackMode=existing ? sensorInstallMode(existing) : 'side';
      const mode=detectInstallModeFromEntities(list) || fallbackMode;
      let v=null;
      for(const suffix of rangeSuffixesForMode(mode)){
        v=readNumberBySuffixFrom(list, suffix);
        if(v!==null) break;
      }
      const existingRange=Number.isFinite(Number(existing?.detRange)) ? Number(existing.detRange) : MAX_RANGE;
      const det=Math.round(Math.max(Y_MIN,Math.min(MAX_RANGE,v??existingRange)));
      const parsedZones=zonesFromEntities(list);
      const zones=parsedZones.hasData ? parsedZones.zones : (existing?.zones || emptyZones());
      updates.set(deviceId, {install_mode: mode, detRange: det, zones});
    });
    if(!updates.size) return;
    floorplanSensors = floorplanSensors.map(s=>{
      const data=updates.get(s.device_id);
      if(!data) return s;
      return {
        ...s,
        install_mode: data.install_mode,
        detRange: data.detRange,
        zones: data.zones
      };
    });
  }

  async function loadFloorplanFromHA(){
    floorplanPolylines=[];
    floorplanActiveLine=null;
    floorplanPreview=null;
    floorplanSensors=[];
    floorplanSensorHover=null;
    floorplanSensorDragging=null;
    floorplanSensorRotating=null;
    floorplanHistory=[];
    floorplanFuture=[];
    resetFPCam();
    if(!selectedFloorId) return false;
    try{
      const r = await fetch(`api/floorplan?floor_id=${encodeURIComponent(selectedFloorId)}`,{
        method:'GET',
        credentials:'include'
      });
      const text=await r.text();
      if(!r.ok){
        throw new Error(text||`${r.status} ${r.statusText}`);
      }
      let parsed=[];
      try{
        parsed=text?JSON.parse(text):[];
      }catch(e){
        throw new Error('JSON parse error: '+(e.message||e));
      }
      if(parsed && Array.isArray(parsed.polylines)){
        floorplanPolylines = parsed.polylines.map(normalizePolyline).filter(l=>l.length);
      }else if(Array.isArray(parsed)){
        const line=normalizePolyline(parsed);
        if(line.length) floorplanPolylines=[line];
      }
      if(parsed){
        if(Array.isArray(parsed.sensors)){
          floorplanSensors = parsed.sensors.map(clampSensorPos);
        }else if(parsed.sensor){
          const s=parsed.sensor;
          const single=clampSensorPos({
            x:s.x, y:s.y, angle:s.angle,
            device_id: s.device_id||s.deviceId||'',
            name: s.name||'',
            model: s.model||'',
            install_mode: s.install_mode ?? s.installMode ?? s.mount_mode ?? s.mountMode ?? s.mode
          });
          floorplanSensors=[single];
        }
        await refreshAllFloorplanSensorsFromHA();
        const lastDev=floorplanSensors[floorplanSensors.length-1]?.device_id||'';
        if(floorplanDeviceSel && lastDev){
          floorplanDeviceSel.value = lastDev;
        }
      }
      resetFloorplanSelectionAndModes();
      pushFloorplanHistory();
      floorplanWallsDirty=false;
      applyFloorplanAutoFit({resetAngles:viewDim==='3d'});
      enqueueDraw();
      return true;
    }catch(e){
      reportError(e?.message || 'No data available');
      return false;
    }
  }

  async function saveFloorplanToHA(){
    if(!selectedFloorId){
      reportError('Save failed');
      return;
    }
    try{
      syncActiveSensorState();
      const sensorsOk = await saveAllFloorplanSensorZones();
      const body={floor_id:selectedFloorId, polylines:floorplanPolylines, sensors:floorplanSensors.map(clampSensorPos)};
      const r = await fetch('api/floorplan',{
        method:'POST',
        headers:{'Content-Type':'application/json'},
        credentials:'include',
        body:JSON.stringify(body)
      });
      const text=await r.text();
      if(!r.ok){
        throw new Error(text||`${r.status} ${r.statusText}`);
      }
      if(sensorsOk){
        resetFloorplanSelectionAndModes();
        enqueueDraw();
        setSaved();
      }
    }catch(e){
      reportError(e?.message || 'Save failed');
    }
  }
  function setCurrentZone(z){
    currentZone=z;
    zoneBtns.forEach(b=>b.classList.toggle('active',b.dataset.zone===z));
    setReady();
  }

  function setFloorplanTool(mode){
    const prevTool = floorplanTool;
    floorplanTool = mode;
    floorplanEditEnabled = (mode === 'draw');
    if(mode==='draw'){
      floorplanPreviewSuppressed=false;
    }
    floorplanToolBtns.forEach(btn=>{
      const active = btn.dataset.tool===mode;
      btn.classList.toggle('active',active);
      btn.setAttribute('aria-pressed', active ? 'true' : 'false');
    });
    if(prevTool === 'draw' && mode !== 'draw'){
      applyFloorplanAutoFit();
    }
    if(mode==='view') setReady();
  }

  function cancelFloorplanTool(){
    if(!floorplanEnabled) return;
    if(floorplanTool==='draw' && floorplanActiveLine!==null){
      const line = floorplanPolylines[floorplanActiveLine];
      if(line && line.length>=2){
        setReady();
      }
    }
    floorplanActiveLine=null;
    floorplanPreview=null;
    setFloorplanTool('view');
    floorplanDragMode=null;
    floorplanSensorHover=null;
    floorplanSensorDragging=null;
    floorplanSensorRotating=null;
    floorplanLengthInput='';
    enqueueDraw();
  }

  function applyTypedLength(){
    if(!floorplanPreviewDir) return false;
    if(floorplanActiveLine===null) return false;
    const line=floorplanPolylines[floorplanActiveLine];
    const lastPt=line && line.length?line[line.length-1]:null;
    if(!lastPt) return false;
    const lenCm=Number(floorplanLengthInput);
    if(!Number.isFinite(lenCm)) return false;
    const nx=clamp(lastPt.x + floorplanPreviewDir.x*lenCm, FLOORPLAN_BOUNDS.xMin, FLOORPLAN_BOUNDS.xMax);
    const ny=clamp(lastPt.y + floorplanPreviewDir.y*lenCm, FLOORPLAN_BOUNDS.yMin, FLOORPLAN_BOUNDS.yMax);
    floorplanPreview={
      x:nx,
      y:ny,
      snapped:false,
      type:null,
      snapLineY:null,
      snapLineX:null
    };
    enqueueDraw();
    return true;
  }

  function pointerDown(px,py,button,shiftKey=false){
    if(button == null) button = 0;

    if(viewDim==='2d' && shiftKey && button===0){
      pan2DDragging=true;
      panLastX=px;
      panLastY=py;
      return;
    }

    if(viewDim==='3d'){
      if(button!==0) return;
      orbitDragging = true;
      orbitDragMode = shiftKey ? 'pan' : 'orbit';
      orbitLastX = px;
      orbitLastY = py;
      return;
    }

    if(floorplanEnabled){
      if(!selectedFloorId){
        reportError('No data available');
        return;
      }
      if(IS_MOBILE){
        return;
      }
      floorplanSensorHover=null;
      if(currentZone && floorplanTool==='zone'){
        handleFloorplanZoneDown(px,py,shiftKey,button);
        return;
      }
      if(floorplanTool!=='draw' && floorplanTool!=='zone'){
        handleFloorplanSelectDown(px,py,shiftKey,button);
        return;
      }
      if(button===0 && floorplanActiveLine!==null && floorplanLengthInput){
        applyTypedLength();
        if(floorplanPreview){
          const line=floorplanPolylines[floorplanActiveLine];
          const lastPt=line && line.length?line[line.length-1]:null;
          if(lastPt){
            line.push({x:floorplanPreview.x,y:floorplanPreview.y});
            floorplanPreview=null;
            markFloorplanWallsDirty();
          }
        }
        floorplanLengthInput='';
        enqueueDraw();
        return;
      }
      if(button===2){
        const hit = floorplanFindVertex(px,py);
        if(hit.idx>=0 && hit.dist<=FLOORPLAN_SNAP_PX){
          pushFloorplanHistory();
          const line=floorplanPolylines[hit.line];
          line.splice(hit.idx,1);
          if(line.length===0){
            floorplanPolylines.splice(hit.line,1);
            if(floorplanActiveLine===hit.line) floorplanActiveLine=null;
          }
          markFloorplanWallsDirty();
        }else{
          const lineIdx = floorplanActiveLine;
          const line = lineIdx!=null ? floorplanPolylines[lineIdx] : null;
          if(line && line.length>=2){
            setReady();
          }
          floorplanActiveLine=null;
        }
        floorplanPreview=null;
        floorplanLengthInput='';
        floorplanPreviewSuppressed=true;
        enqueueDraw();
        return;
      }
      if(button!==0) return;
      floorplanPreviewSuppressed=false;
      lastPX=px;
      lastPY=py;

      const snap = snapToFloorplan(px,py);
      const lastLine = floorplanActiveLine!=null ? floorplanPolylines[floorplanActiveLine] : null;
      const lastPt = lastLine && lastLine.length ? lastLine[lastLine.length-1] : null;
      let world = snap ? {x:snap.x,y:snap.y} : floorplanWorldPointFromPx(px,py);
      world = applyAxisSnap(world,lastPt,false);
      const hs = applyHeightSnap(world, px, py);
      world = hs.world;
      const ws = applyWidthSnap(world, px, py);
      world = ws.world;
      const dirX = world.x - (lastPt?.x ?? world.x);
      const dirY = world.y - (lastPt?.y ?? world.y);
      const len = Math.hypot(dirX,dirY)||1;
      floorplanPreviewDir = {x:dirX/len,y:dirY/len};

      if(floorplanActiveLine===null){
        pushFloorplanHistory();
        floorplanPolylines.push([world]);
        floorplanActiveLine=floorplanPolylines.length-1;
        markFloorplanWallsDirty();
        setReady();
      }else{
        pushFloorplanHistory();
        floorplanPolylines[floorplanActiveLine].push(world);
        markFloorplanWallsDirty();
      }
      floorplanPreview=null;
      enqueueDraw();
      return;
    }

    lastPX=px;
    lastPY=py;
    dragWhole=false;

    if(!currentZone){
      const hit = hitZoneAt(px,py);
      if(hit){
        setCurrentZone(hit);
        dragWhole=true;
      }
      return;
    }

        const pts=zones[currentZone];
    if(!pts) return;

    if(button === 2){
      const idx = nearestIdx(px,py);
      if(idx >= 0){
        pushFloorplanHistory();
        pts.splice(idx, 1);
        dragIdx = null;
        dragWhole = false;
        enqueueDraw();
      }
      return;
    }

    const idx=nearestIdx(px,py);
    if(idx>=0){
      dragIdx=idx;
      enqueueDraw();
      return;
    }

    if(pts.length>=2 && pts.length<MAX_POINTS){
      const edge=nearestEdge(px,py);
      if(edge.idx>=0){
        const x=Math.round(toCmX(px)), y=Math.round(toCmY(py));
        const p={x,y};
        const insertAt=edge.idx+1;
        pts.splice(insertAt,0,p);
        dragIdx=insertAt;
        enqueueDraw();
        return;
      }
    }

    const hit=hitZoneAt(px,py);
    if(hit){
      if(hit!==currentZone){
        setCurrentZone(hit);
      }
      dragWhole=true;
      dragIdx=null;
      return;
    }

    if(pts.length>=MAX_POINTS) return;
    const x=Math.round(toCmX(px)), y=Math.round(toCmY(py));
    pushFloorplanHistory();
    pts.push({x,y});
    enqueueDraw();

  }

  function pointerMove(px,py,shiftKey=false){
    if(pan2DDragging){
      const dx = px - panLastX;
      const dy = py - panLastY;
      panLastX = px;
      panLastY = py;
      pan2D(dx,dy);
      enqueueDraw();
      return;
    }
    if(viewDim==='3d'){
      if(!orbitDragging) return;
      const dx = px - orbitLastX;
      const dy = py - orbitLastY;
      orbitLastX = px;
      orbitLastY = py;
      if(orbitDragMode === 'pan'){
        panOrbit(dx, dy);
      }else{
        ORBIT.azimuth += dx * ORBIT_ROTATE_SPEED;
        ORBIT.elevation = clamp(ORBIT.elevation + dy * ORBIT_ROTATE_SPEED, ORBIT_LIMITS.minElev, ORBIT_LIMITS.maxElev);
      }
      enqueueDraw();
      return;
    }

    if(floorplanEnabled){
      if(IS_MOBILE) return;
      if((floorplanSensorDragging!==null || floorplanSensorRotating!==null)){
        handleFloorplanSelectMove(px,py);
        return;
      }
      if(currentZone && floorplanTool==='zone'){
        handleFloorplanZoneMove(px,py);
        return;
      }
      if(floorplanTool!=='draw' && floorplanTool!=='zone'){
        handleFloorplanSelectMove(px,py);
        return;
      }
      if(floorplanPreviewSuppressed){
        if(floorplanPreview){
          floorplanPreview=null;
          enqueueDraw();
        }
        return;
      }
      const snap=snapToFloorplan(px,py);
      const line = floorplanActiveLine!=null ? floorplanPolylines[floorplanActiveLine] : null;
      const lastPt = line && line.length ? line[line.length-1] : null;
      let world = snap ? {x:snap.x,y:snap.y} : floorplanWorldPointFromPx(px,py);
      world = applyAxisSnap(world,lastPt,false);
      const hs = applyHeightSnap(world, px, py);
      world = hs.world;
      const ws = applyWidthSnap(world, px, py);
      world = ws.world;
      const dirX = world.x - (lastPt?.x ?? world.x);
      const dirY = world.y - (lastPt?.y ?? world.y);
      const len = Math.hypot(dirX,dirY)||1;
      floorplanPreviewDir = {x:dirX/len,y:dirY/len};
      floorplanPreview={
        x:world.x,
        y:world.y,
        snapped:!!snap,
        type:snap?.type||null,
        snapLineY:hs.snapLineY,
        snapLineX:ws.snapLineX
      };
      enqueueDraw();
      return;
    }

    if(dragIdx==null && !dragWhole) return;
    if(dragWhole){
      const dx=toCmX(px)-toCmX(lastPX);
      const dy=toCmY(py)-toCmY(lastPY);
      const pts=zones[currentZone];
      const next=pts.map(p=>({x:p.x+dx, y:p.y+dy}));
      for(let i=0;i<pts.length;i++){
        pts[i]=next[i];
      }
      lastPX=px;
      lastPY=py;
      enqueueDraw();
      return;
    }
    const pts=zones[currentZone];
    const c={x:toCmX(px), y:toCmY(py)};
    pts[dragIdx]={
      x:Math.round(c.x),
      y:Math.round(c.y)
    };
    enqueueDraw();
  }

  function pointerUp(){
    pan2DDragging=false;
    if(viewDim==='3d'){
      orbitDragging=false;
      orbitDragMode='orbit';
      return;
    }
    if(floorplanEnabled){
      finishFloorplanInteraction();
      return;
    }
    dragIdx=null;
    dragWhole=false;
  }


  window.addEventListener('keydown',e=>{
    if(e.key==='Escape'){
      cancelFloorplanTool();
      dragIdx=null;
      dragWhole=false;
      floorplanLengthInput='';
      return;
    }

    if(floorplanEnabled && (e.key==='z' || e.key==='Z') && (e.metaKey || e.ctrlKey)){
      e.preventDefault();
      if(e.shiftKey){
        redoFloorplan();
      }else{
        undoFloorplan();
      }
      return;
    }
    if(floorplanEnabled && (e.key==='y' || e.key==='Y') && (e.metaKey || e.ctrlKey)){
      e.preventDefault();
      redoFloorplan();
      return;
    }

    if(floorplanEnabled && floorplanEditEnabled && floorplanActiveLine!==null){
      const tag=(document.activeElement?.tagName||'').toLowerCase();
      if(tag==='input' || tag==='textarea' || tag==='select') return;
      if(e.key>='0' && e.key<='9'){
        floorplanLengthInput+=e.key;
        applyTypedLength();
        e.preventDefault();
      }else if(e.key==='Backspace'){
        floorplanLengthInput=floorplanLengthInput.slice(0,-1);
        applyTypedLength();
        e.preventDefault();
      }else if(e.key==='Enter'){
        applyTypedLength();
        if(floorplanPreview && floorplanActiveLine!==null){
          const line=floorplanPolylines[floorplanActiveLine];
          const lastPt=line && line.length?line[line.length-1]:null;
          if(lastPt){
            pushFloorplanHistory();
            line.push({x:floorplanPreview.x,y:floorplanPreview.y});
            floorplanPreview=null;
            markFloorplanWallsDirty();
            applyFloorplanAutoFitIfDirty();
            enqueueDraw();
          }
        }
        floorplanLengthInput='';
        e.preventDefault();
      }
    }
  });

  const loadDeviceEntities=pauseDuring(loadDeviceEntitiesCore);
  const loadDetectionRange=pauseDuring(loadDetectionRangeCore);
  const setDetectionRange=pauseDuring(()=>setDetectionRangeCore(activeRangeInput()));
  const setFloorplanDetectionRange=pauseDuring(()=>setDetectionRangeCore(floorplanRangeInput));
  const loadZone=pauseDuring(loadZoneCore);
  const loadAll=pauseDuring(loadAllCore);
  const saveCurrentZone=pauseDuring(saveCurrentZoneCore);
  const saveAllZones=pauseDuring(saveAllZonesForSelectedDevice);
  const saveFloorplan=pauseDuring(saveFloorplanToHA);

  cvs.addEventListener('mousedown',e=>{
    const p=localPoint(e.clientX,e.clientY);
    pointerDown(p.x,p.y, e.button, e.shiftKey);
  });
  window.addEventListener('mousemove',e=>{
    const p=localPoint(e.clientX,e.clientY);
    pointerMove(p.x,p.y, e.shiftKey);
  });
  window.addEventListener('mouseup',()=>{ pointerUp(); });
  cvs.addEventListener('contextmenu',e=>e.preventDefault());

  cvs.addEventListener('wheel',e=>{
    const p=localPoint(e.clientX,e.clientY);
    if(viewDim==='3d'){
      if(!zoomAllowed()) return;
      e.preventDefault();
      const delta = e.deltaY || e.wheelDelta || 0;
      if(!delta) return;
      const factor = delta>0 ? 1.1 : 0.9;
      ORBIT.distance = clamp(ORBIT.distance * factor, ORBIT_LIMITS.minDist, ORBIT_LIMITS.maxDist);
      enqueueDraw();
      return;
    }
    if(viewDim==='2d'){
      if(!zoomAllowed()) return;
      e.preventDefault();
      const delta = e.deltaY || e.wheelDelta || 0;
      if(!delta) return;
      const factor = delta>0 ? 1.08 : 0.92;
      zoom2D(factor, p.x, p.y);
      enqueueDraw();
    }
  },{passive:false});

  function touchDistance(t1,t2){
    const dx = t1.clientX - t2.clientX;
    const dy = t1.clientY - t2.clientY;
    return Math.hypot(dx,dy);
  }

  function canUseFloorplanGestures(){
    return !floorplanEnabled || shouldAutoFitFloorplanNow();
  }

  cvs.addEventListener('touchstart',e=>{
    if(viewDim==='2d'){
      if(e.touches.length===2){
        if(!zoomAllowed() || !canUseFloorplanGestures()){
          e.preventDefault();
          return;
        }
        if(touchMode === 'pointer') pointerUp();
        pinchZooming = true;
        orbitDragging = false;
        touchMode = 'pinch';
        pinchLastDist = touchDistance(e.touches[0], e.touches[1]);
        e.preventDefault();
        return;
      }
      if(e.touches.length===1){
        const t=e.touches[0];
        if(!t) return;
        const p=localPoint(t.clientX,t.clientY);
        touchMode = 'pointer';
        pointerDown(p.x,p.y, 0, false);
        e.preventDefault();
        return;
      }
      return;
    }
    if(viewDim==='3d' && e.touches.length===2){
      if(!zoomAllowed()){
        e.preventDefault();
        return;
      }
      if(touchMode === 'pointer') pointerUp();
      pinchZooming = true;
      orbitDragging = false;
      touchMode = 'pinch';
      pinchLastDist = touchDistance(e.touches[0], e.touches[1]);
      e.preventDefault();
      return;
    }
    const t=e.touches[0];
    if(!t) return;
    const p=localPoint(t.clientX,t.clientY);
    touchMode = 'pointer';
    pointerDown(p.x,p.y, 0, false);
    e.preventDefault();
  },{passive:false});

  cvs.addEventListener('touchmove',e=>{
    if(touchMode === 'pinch' && e.touches.length>=2){
      if(viewDim==='2d' && (!zoomAllowed() || !canUseFloorplanGestures())){
        e.preventDefault();
        return;
      }
      if(viewDim==='3d' && !zoomAllowed()){
        e.preventDefault();
        return;
      }
      const t1=e.touches[0], t2=e.touches[1];
      const d = touchDistance(t1, t2);
      const midX = (t1.clientX + t2.clientX) * 0.5;
      const midY = (t1.clientY + t2.clientY) * 0.5;
      if(viewDim==='3d'){
        if(d>0 && pinchLastDist>0){
          const factor = pinchLastDist / d;
          ORBIT.distance = clamp(ORBIT.distance * factor, ORBIT_LIMITS.minDist, ORBIT_LIMITS.maxDist);
        }
      }else{
        if(d>0 && pinchLastDist>0){
          const currMid = localPoint(midX, midY);
          const factor = d / pinchLastDist;
          zoom2D(factor, currMid.x, currMid.y);
        }
      }
      pinchLastDist = d;
      enqueueDraw();
      e.preventDefault();
      return;
    }
    if(touchMode === 'pointer' && e.touches.length===1){
      const t=e.touches[0];
      if(!t) return;
      const p=localPoint(t.clientX,t.clientY);
      pointerMove(p.x,p.y);
      e.preventDefault();
    }
  },{passive:false});

  cvs.addEventListener('touchend',e=>{
    if(touchMode === 'pinch' && e.touches.length<2){
      pinchZooming=false;
      pinchLastDist=0;
      touchMode=null;
      return;
    }
    if(touchMode === 'pointer' && e.touches.length===0){
      pointerUp();
      touchMode=null;
    }
  },{passive:true});
  cvs.addEventListener('touchcancel',e=>{
    pinchZooming=false;
    pinchLastDist=0;
    touchMode=null;
    pointerUp();
  },{passive:true});

  zoneBtns.forEach(btn=>{
    btn.addEventListener('click',pauseDuring(async()=>{
      const zoneId = btn.dataset.zone;
      const dev = placementDevice() || selectedDevice;
      if(!dev){
        reportError('No data available');
        return;
      }
      setCurrentZone(zoneId);
      enqueueDraw();
    }));
  });

  clearBtn.addEventListener('click',pauseDuring(async()=>{
    if(floorplanEnabled){
      floorplanPolylines=[];
      floorplanActiveLine=null;
      floorplanPreview=null;
      floorplanSensors=[];
      floorplanSensorHover=null;
      floorplanSensorDragging=null;
      floorplanSensorRotating=null;
      floorplanDragMode=null;
      floorplanHistory=[];
      floorplanFuture=[];
      floorplanWallsDirty=false;
      applyFloorplanAutoFit({resetAngles:viewDim==='3d'});
      enqueueDraw();
      setCleared();
      return;
    }
    if(!currentZone){
      return;
    }
    zones[currentZone]=[];
    enqueueDraw();
    setCleared();
  }));

  saveBtn.addEventListener('click',()=>{
    if(floorplanEnabled) saveFloorplan();
    else saveAllZones();
  });
  rangeSetBtn.addEventListener('click',setDetectionRange);
  rangeInput.addEventListener('keydown',e=>{
    if(e.key==='Enter') setDetectionRange();
  });
  if(floorplanRangeSetBtn){
    floorplanRangeSetBtn.addEventListener('click',setFloorplanDetectionRange);
  }
  if(floorplanRangeInput){
    floorplanRangeInput.addEventListener('keydown',e=>{
      if(e.key==='Enter') setFloorplanDetectionRange();
    });
  }

  function setViewModeButtons(mode, {silent=false}={}){
    viewMode = mode;
    liveModeBtn.classList.remove('btn-primary','btn-plain');
    heatmapModeBtn.classList.remove('btn-primary','btn-plain');

    liveModeBtn.classList.add(mode==='live'?'btn-primary':'btn-plain');
    heatmapModeBtn.classList.add(mode==='heatmap'?'btn-primary':'btn-plain');

    resetOrbitIf3D();
    persistUiState();
    if(!silent){
      setReady();
    }
  }

  async function restoreUiState(){
    const state=loadUiState();
    if(!state) return;
    if(state.viewDim) viewDim=normalizeViewDim(state.viewDim);
    if(state.viewMode) viewMode=normalizeViewMode(state.viewMode);
    if(typeof state.selectedFloorId==='string') selectedFloorId=state.selectedFloorId;

    if(state.floorplanEnabled){
      if(!floorplanEnabled) await setFloorplanEnabled(true);
      return;
    }

    if(state.viewMode === 'heatmap'){
      if(viewDim === '3d') await switchToHeatmap3D();
      else await switchToHeatmap2D();
      return;
    }

    setViewModeButtons('live', {silent:true});
    if(viewDim === '3d') resetOrbit(defaultOrbitDistance());
    else reset2DCam();
    enqueueDraw();
    setReady();
  }

  liveModeBtn.addEventListener('click',function(){
    setViewModeButtons('live', {silent:true});
    if(viewDim==='2d'){
      if(floorplanEnabled) resetFPCam();
      else reset2DCam();
    }
    enqueueDraw();
    if(selectedDevice) resumeLive(true);
    setReady();
  });

  async function ensureHeatmapData(){
    if(!selectedDevice) return false;
    if(heatmapPositions.length) return true;
    const targetEntityIds=entities.filter(e=>
      e.entity_id.endsWith('target_1_x')||e.entity_id.endsWith('target_1_y')||
      e.entity_id.endsWith('target_2_x')||e.entity_id.endsWith('target_2_y')||
      e.entity_id.endsWith('target_3_x')||e.entity_id.endsWith('target_3_y')||
      e.entity_id.endsWith('target_4_x')||e.entity_id.endsWith('target_4_y')||
      e.entity_id.endsWith('target_5_x')||e.entity_id.endsWith('target_5_y')
    ).map(e=>e.entity_id);
    const hours=Number(heatmapHoursSel.value);
    setLoadingHeatmap();
    try{
      heatmapPositions=await fetchHistoricalData(targetEntityIds,hours);
      heatmapFieldColor=null;
      heatmapFieldHeight=null;
      return true;
    }catch(e){
      heatmapPositions=[];
      heatmapFieldColor=null;
      heatmapFieldHeight=null;
      reportError(e?.message || 'No data available');
      setReady();
      return false;
    }
  }

  async function switchToHeatmap2D(){
    if(!selectedDevice) return;
    setViewModeButtons('heatmap', {silent:true});
    if(floorplanEnabled) resetFPCam();
    else reset2DCam();
    const ok = await ensureHeatmapData();
    if(ok) setReady();
    enqueueDraw();
  }

  async function switchToHeatmap3D(){
    if(!selectedDevice) return;
    setViewModeButtons('heatmap', {silent:true});
    resetOrbit(defaultOrbitDistance());
    const ok = await ensureHeatmapData();
    if(ok) setReady();
    enqueueDraw();
  }

  heatmapModeBtn.addEventListener('click', async () => {
    if(floorplanEnabled){
      return;
    }
    if (!selectedDevice) return;

    if (viewDim === '3d') {
      await switchToHeatmap3D();
    } else {
      await switchToHeatmap2D();
    }
  });

  viewToggleBtns.forEach(btn=>{
    btn.addEventListener('click', async ()=>{
      if(!selectedDevice && !floorplanEnabled) return;
      const v = btn.dataset.view;
      if(v === '2d'){
        viewDim = '2d';
        if(floorplanEnabled) applyFloorplanAutoFit();
        else reset2DCam();
        setReady();
        enqueueDraw();
      } else {
        viewDim = '3d';
        if(floorplanEnabled) applyFloorplanAutoFit({resetAngles:true});
        else resetOrbit(defaultOrbitDistance());
        if(viewMode === 'heatmap'){
          await ensureHeatmapData();
        }
        setReady();
        enqueueDraw();
      }
      persistUiState();
    });
  });

  async function setFloorplanEnabled(nextEnabled){
    floorplanEnabled=nextEnabled;
    floorplanBtn.classList.toggle('active',floorplanEnabled);
    floorplanBtn.setAttribute('aria-pressed', floorplanEnabled ? 'true' : 'false');
    dragIdx=null;
    dragWhole=false;
    floorplanActiveLine=null;
    floorplanPreview=null;
    floorplanPreviewSuppressed=false;
    floorplanDragMode=null;
    floorplanHistory=[];
    floorplanFuture=[];
    resetFPCam();
    reset2DCam();
    setFloorplanTool('view');
    if(floorplanEnabled){
      try{
        await loadFloorsCore();
        if(!floorsList.length){
          reportError('No data available');
        }else{
          const loaded = await loadFloorplanFromHA();
          if(loaded) setReady();
        }
      }catch(e){
        reportError(e?.message || 'No data available');
      }
    }
    showDeviceSelector();
    resetOrbitIf3D();
    if(viewControls && modeTitle){
      if(floorplanEnabled){
        modeTitle.textContent='Detection range';
        viewControls.style.display='none';
        if(floorplanRangeControls) floorplanRangeControls.style.display='flex';
        if(viewDim==='3d') applyFloorplanAutoFit({resetAngles:true});
      }else{
        modeTitle.textContent='View Mode';
        viewControls.style.display='flex';
        if(floorplanRangeControls) floorplanRangeControls.style.display='none';
        setFloorplanTool('view');
        resetOrbit(defaultOrbitDistance());
      }
    }
    if(!floorplanEnabled) setReady();
    enqueueDraw();
    persistUiState();
  }

  floorplanBtn.addEventListener('click',pauseDuring(async()=>{
    await setFloorplanEnabled(!floorplanEnabled);
  }));

  legendSigmaBtns.forEach(btn=>{
    const clearPressed=()=>{
      btn.classList.remove('active');
    };
    btn.addEventListener('pointerdown',e=>{
      btn.classList.add('active');
      if(btn.setPointerCapture) btn.setPointerCapture(e.pointerId);
    });
    btn.addEventListener('pointerup',e=>{
      clearPressed();
      if(btn.releasePointerCapture) btn.releasePointerCapture(e.pointerId);
    });
    btn.addEventListener('pointerleave',clearPressed);
    btn.addEventListener('pointercancel',clearPressed);
    btn.addEventListener('click',()=>{
      const op = btn.dataset.op;
      const step = 0.2;
      const minSigma = 0.3;
      const maxSigma = 2.5;

      if(op === 'minus'){
        TUNE.sigmaScale = clamp(TUNE.sigmaScale - step, minSigma, maxSigma);
      }else if(op === 'plus'){
        TUNE.sigmaScale = clamp(TUNE.sigmaScale + step, minSigma, maxSigma);
      }

      heatmapFieldColor=null;
      heatmapFieldHeight=null;
      enqueueDraw();
    });
  });

  heatmapHoursSel.addEventListener('change', async ()=>{
    heatmapPositions=[];
    heatmapFieldColor=null;
    heatmapFieldHeight=null;
    if(viewMode === 'heatmap'){
      if(viewDim === '3d') await switchToHeatmap3D();
      else await switchToHeatmap2D();
    }
  });

  floorplanToolBtns.forEach(btn=>{
    btn.addEventListener('click',()=>{
      const tool=btn.dataset.tool;
      if(tool==='sensor'){
        setStatusText('Click to place selected sensor');
      }else if(tool==='draw'){
        setStatusText('Click to draw walls');
      }else if(tool==='zone'){
        setStatusText('Click to draw zone');
      }
      if(!floorplanEnabled){
        return;
      }
      if(floorplanTool === tool){
        cancelFloorplanTool();
        return;
      }
      if(tool==='sensor'){
        const dev=placementDevice();
        if(!dev){
          reportError('Sensor placement failed');
        }
        setFloorplanTool('sensor');
      }else if(tool==='draw'){
        setFloorplanTool('draw');
      }else if(tool==='zone'){
        const sensor = activeFloorplanSensor();
        if(!sensor){
          reportError('Zone is not valid');
        }
        if(!currentZone){
          currentZone='1';
          zoneBtns.forEach(b=>b.classList.toggle('active', b.dataset.zone==='1'));
        }
        setFloorplanTool('zone');
      }
    });
  });

  function flashButton(btn){
    if(!btn) return;
    btn.classList.add('active');
    setTimeout(()=>btn.classList.remove('active'),140);
  }

  if(floorplanUndoBtn){
    floorplanUndoBtn.addEventListener('click',()=>{
      if(!floorplanEnabled) return;
      undoFloorplan();
      flashButton(floorplanUndoBtn);
    });
  }
  if(floorplanRedoBtn){
    floorplanRedoBtn.addEventListener('click',()=>{
      if(!floorplanEnabled) return;
      redoFloorplan();
      flashButton(floorplanRedoBtn);
    });
  }

  async function handleDeviceSelection(selectEl){
    if(!selectEl || !selectEl.value){
      reportError('No data available');
      return;
    }
    selectedDevice={
      device_id:selectEl.value,
      name:selectEl.options[selectEl.selectedIndex]?.textContent||selectEl.value,
      model:selectEl.options[selectEl.selectedIndex]?.dataset.model||''
    };
    persistUiState();
    livePos = livePosFor(selectedDevice.device_id);
    heatmapPositions=[];
    heatmapFieldColor=null;
    heatmapFieldHeight=null;
    setViewModeButtons('live');
    TUNE.sigmaScale = 1.0;
    legendSigmaBtns.forEach(b=>b.classList.remove('active'));
    currentZone = null;
    zoneBtns.forEach(b=>b.classList.remove('active'));
    try{
      const loaded = await fetchZonesFromDevice(selectedDevice);
      if(viewDim === '2d') reset2DCam();
      else resetOrbitIf3D();
      setReady();
    }catch(e){
      reportError(e?.message || 'No data available');
    }finally{
      syncLayout();
      resumeLive(true);
      syncFloorplanDeviceSelector();
    }
  }

  (async()=>{
    try{
      pauseLive();
      initialUiState=loadUiState();
      await api('api/template',{template:'{{ 1+1 }}'});
      const res=await api('api/template',{template:TPL_LIST});
      const list=typeof res==='string'?JSON.parse(res||'[]'):res;
      devicesList = list;
      populateDevices(devicesList, initialUiState?.selectedDeviceId || null);
      if(!devicesList.length){
        reportError('No data available');
        return;
      }
      selectedDevice={
        device_id:sel.value,
        name:sel.options[sel.selectedIndex]?.textContent||sel.value,
        model:sel.options[sel.selectedIndex]?.dataset.model||''
      };
      livePos = livePosFor(selectedDevice.device_id);
      syncFloorplanDeviceSelector();
      await fetchZonesFromDevice(selectedDevice);
      setReady();
      await restoreUiState();
    }catch(e){
      reportError(e?.message || 'No data available');
    }finally{
      const ro=new ResizeObserver(()=>{
        if(resizeScheduled) return;
        resizeScheduled=true;
        requestAnimationFrame(()=>{
          resizeScheduled=false;
          syncLayout();
        });
      });
      ro.observe(container);
      ro.observe(panelCard);
      window.addEventListener('resize',syncLayout);
      document.addEventListener('visibilitychange',()=>{
        if(document.visibilityState==='hidden') pauseLive();
        else resumeLive(true);
      });
      legendSigmaBtns.forEach(b=>b.classList.remove('active'));
      syncLayout();
      resumeLive(true);
      document.body.style.opacity = '1';
    }
  })();

  sel.addEventListener('change',pauseDuring(async()=>{
    if(floorplanEnabled){
      selectedFloorId = sel.value || null;
      if(!selectedFloorId){
        reportError('No data available');
        return;
      }
      persistUiState();
      const loaded = await loadFloorplanFromHA();
      if(loaded) setReady();
      enqueueDraw();
      return;
    }
    await handleDeviceSelection(sel);
  }));

  if(floorplanDeviceSel){
    floorplanDeviceSel.addEventListener('change',pauseDuring(async()=>{
      await handleDeviceSelection(floorplanDeviceSel);
    }));
  }

})();
</script>
</body>
</html> 